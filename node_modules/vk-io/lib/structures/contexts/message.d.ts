import { Context, ContextFactoryOptions, ContextDefaultState } from './context';
import { Params } from '../../api';
import { MessageForwardsCollection, Attachmentable, IAllAttachmentable } from '../shared';
import { Attachment, ExternalAttachment } from '../attachments';
import { kSerializeData } from '../../utils/constants';
import { AllowArray } from '../../types';
import { KeyboardBuilder } from '../keyboard';
import { IUploadSourceMedia } from '../../upload';
export type MessageContextType = 'message';
export type MessageContextPayloadEventType = 'chat_photo_update' | 'chat_photo_remove' | 'chat_create' | 'chat_title_update' | 'chat_invite_user' | 'chat_kick_user' | 'chat_pin_message' | 'chat_unpin_message' | 'chat_invite_user_by_link';
export type MessageContextSubType = 'message_new' | 'message_edit' | 'message_reply' | MessageContextPayloadEventType;
declare const kForwards: unique symbol;
declare const kReplyMessage: unique symbol;
declare const kMessagePayload: unique symbol;
declare const kAttachments: unique symbol;
export interface IMessageContextSendOptions extends Params.MessagesSendParams {
    attachment?: AllowArray<Attachment | string>;
    keyboard?: KeyboardBuilder | string;
}
export interface IMessageContextPayload {
    message: {
        id: number;
        conversation_message_id: number;
        out: number;
        peer_id: number;
        from_id: number;
        text?: string;
        date: number;
        update_time?: number;
        random_id: number;
        ref?: string;
        ref_source?: string;
        attachments: object[];
        important: boolean;
        geo?: {
            type: 'point';
            coordinates: {
                latitude: number;
                longitude: number;
            };
            place?: {
                id: number;
                title?: string;
                latitude?: number;
                longitude?: number;
                created?: number;
                icon?: string;
                country: number;
                city: string;
                type?: number;
                group_id?: number;
                group_photo?: string;
                checkins?: number;
                updated?: number;
                address?: number;
            };
        };
        payload?: string;
        reply_message?: IMessageContextPayload['message'];
        fwd_messages?: IMessageContextPayload['message'][];
        action?: {
            type: MessageContextPayloadEventType;
            member_id?: number;
            text?: string;
            email?: string;
            photo?: {
                photo_50: string;
                photo_100: string;
                photo_200: string;
            };
        };
        admin_author_id?: number;
        is_cropped?: boolean;
        members_count?: number;
        was_listened?: boolean;
        pinned_at?: number;
        message_tag?: string;
        is_expired?: boolean;
    };
    client_info: {
        button_actions: ('text' | 'vkpay' | 'open_app' | 'location' | 'open_link' | 'callback')[];
        keyboard: boolean;
        inline_keyboard: boolean;
        carousel: boolean;
        lang_id: number;
    };
}
export type MessageContextOptions<S> = ContextFactoryOptions<IMessageContextPayload, S>;
declare class MessageContext<S = ContextDefaultState> extends Context<IMessageContextPayload, S, MessageContextType, MessageContextSubType> {
    $match: RegExpMatchArray;
    text?: string;
    protected $filled: boolean;
    protected [kForwards]: MessageForwardsCollection<S>;
    protected [kReplyMessage]: MessageContext<S> | undefined;
    protected [kAttachments]: (Attachment | ExternalAttachment)[];
    protected [kMessagePayload]: any | undefined;
    constructor(options: MessageContextOptions<S>);
    /**
     * Load message payload
     */
    loadMessagePayload({ force }?: {
        force?: boolean | undefined;
    }): Promise<void>;
    /**
     * Checks if there is text
     */
    get hasText(): boolean;
    /**
     * Checks for reply message
     */
    get hasReplyMessage(): boolean;
    /**
     * Checks for forwarded messages
     */
    get hasForwards(): boolean;
    /**
     * Checks for hast message payload
     */
    get hasMessagePayload(): boolean;
    /**
     * Checks if there is text
     */
    get hasGeo(): boolean;
    /**
     * Checks is a chat
     */
    get isChat(): boolean;
    /**
     * Check is a user
     */
    get isUser(): boolean;
    /**
     * Checks is a group
     */
    get isGroup(): boolean;
    /**
     * Checks is from the user
     */
    get isFromUser(): boolean;
    /**
     * Checks is from the group
     */
    get isFromGroup(): boolean;
    /**
     * Checks a message has arrived in direct messages
     */
    get isDM(): boolean;
    /**
     * Check is special event
     */
    get isEvent(): boolean;
    /**
     * Checks whether the message is outbox
     */
    get isOutbox(): boolean;
    /**
     * Checks whether the message is inboxed
     */
    get isInbox(): boolean;
    /**
     * Checks that the message is important
     */
    get isImportant(): boolean;
    /**
     * Returns the identifier message
     */
    get id(): number;
    /**
     * Returns the conversation message id
     */
    get conversationMessageId(): number | undefined;
    /**
     * Returns the destination identifier
     */
    get peerId(): number;
    /**
     * Returns the peer type
     */
    get peerType(): string;
    /**
     * Returns the sender identifier
     */
    get senderId(): number;
    /**
     * Returns the sender type
     */
    get senderType(): string;
    /**
     * Returns the identifier chat
     */
    get chatId(): number | undefined;
    /**
     * Returns the referral value
     */
    get referralValue(): string | undefined;
    /**
     * Returns the referral source
     */
    get referralSource(): string | undefined;
    /**
     * Returns the date when this message was created
     */
    get createdAt(): number;
    /**
     * Returns the date when this message was updated
     */
    get updatedAt(): number | undefined;
    /**
     * Returns geo
     */
    get geo(): IMessageContextPayload['message']['geo'] | undefined;
    /**
     * Returns the sender (admin community) identifier, only for community messages
     */
    get adminAuthorId(): IMessageContextPayload['message']['admin_author_id'] | undefined;
    /**
     * Checks whether the message is cropped for bot
     */
    get isCropped(): IMessageContextPayload['message']['is_cropped'] | undefined;
    /**
     * Returns the members count
     */
    get membersCount(): IMessageContextPayload['message']['members_count'] | undefined;
    /**
     * Checks whether the attached audio message has already been listened by you
     */
    get wasListened(): IMessageContextPayload['message']['was_listened'] | undefined;
    /**
     * Returns the date when this message was pinned
     */
    get pinnedAt(): IMessageContextPayload['message']['pinned_at'] | undefined;
    /**
     * Returns the string for matching user Notify and VK
     */
    get messageTag(): IMessageContextPayload['message']['message_tag'] | undefined;
    /**
     * Checks whether the message is expired
     */
    get isExpired(): IMessageContextPayload['message']['is_expired'] | undefined;
    /**
     * Returns the event name
     */
    get eventType(): MessageContextPayloadEventType | undefined;
    /**
     * Returns the event member id
     */
    get eventMemberId(): number | undefined;
    /**
     * Returns the event name
     */
    get eventText(): string | undefined;
    /**
     * Returns the event email
     */
    get eventEmail(): string | undefined;
    /**
     * Returns the message payload
     */
    get messagePayload(): any | undefined;
    /**
     * Returns the forwards
     */
    get forwards(): MessageForwardsCollection<S>;
    /**
     * Returns the reply message
     */
    get replyMessage(): MessageContext<S> | undefined;
    /**
     * Returns the attachments
     */
    get attachments(): (Attachment | ExternalAttachment)[];
    /**
     * Returns the capabilities of the client the user is using.
     */
    get clientInfo(): IMessageContextPayload['client_info'];
    /**
     * Edits a message
     */
    editMessage(params: IMessageContextSendOptions): Promise<number>;
    /**
     * Sends a message to the current dialog
     */
    send(text: string | IMessageContextSendOptions, params?: IMessageContextSendOptions): Promise<MessageContext<S>>;
    /**
     * Responds to the current message
     */
    reply(text: string | IMessageContextSendOptions, params?: IMessageContextSendOptions): Promise<MessageContext<S>>;
    /**
     * Sends a photos to the current dialog
     */
    sendPhotos(rawSources: AllowArray<IUploadSourceMedia>, params?: IMessageContextSendOptions): Promise<MessageContext<S>>;
    /**
     * Sends a documents to the current dialog
     */
    sendDocuments(rawSources: AllowArray<IUploadSourceMedia>, params?: IMessageContextSendOptions): Promise<MessageContext<S>>;
    /**
     * Sends an audio message to the current dialog
     */
    sendAudioMessage(source: IUploadSourceMedia, params?: IMessageContextSendOptions): Promise<MessageContext<S>>;
    /**
     * Changes the status of typing in the dialog
     */
    setActivity(): Promise<boolean>;
    /**
     * Deletes the message
     */
    deleteMessage(options?: Partial<Params.MessagesDeleteParams>): Promise<boolean>;
    /**
     * Restores the message
     */
    restoreMessage(): Promise<boolean>;
    /**
     * Return alias of payload.message
     */
    protected get message(): IMessageContextPayload['message'];
    /**
     * Applies the payload
     */
    private applyPayload;
    /**
     * Returns the custom data
     */
    [kSerializeData](): object;
}
interface MessageContext extends Attachmentable, IAllAttachmentable {
}
export { MessageContext };
