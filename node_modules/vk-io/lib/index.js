'use strict';

var createDebug = require('debug');
var abortController = require('abort-controller');
var inspectable = require('inspectable');
var https = require('https');
var formdataNode = require('formdata-node');
var formDataEncoder = require('form-data-encoder');
var fs = require('fs');
var stream = require('stream');
var middlewareIo = require('middleware-io');
var url = require('url');
var http = require('http');
var util = require('util');

/**
 * General error class
 */
class VKError extends Error {
    /**
     * Constructor
     */
    constructor({ code, message, cause }) {
        super(message, {
            cause
        });
        this.code = code;
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Returns property for json
     */
    toJSON() {
        const json = {};
        for (const key of Object.getOwnPropertyNames(this)) {
            json[key] = this[key];
        }
        return json;
    }
}

/* eslint-disable */
exports.APIErrorCode = void 0;
(function (APIErrorCode) {
    /**
     * Unknown error occurred
     *
     * Code: `1`
     */
    APIErrorCode[APIErrorCode["UNKNOWN"] = 1] = "UNKNOWN";
    /**
     * Application is disabled. Enable your application or use test mode
     *
     * Code: `2`
     */
    APIErrorCode[APIErrorCode["DISABLED"] = 2] = "DISABLED";
    /**
     * Unknown method passed
     *
     * Code: `3`
     */
    APIErrorCode[APIErrorCode["METHOD"] = 3] = "METHOD";
    /**
     * Incorrect signature
     *
     * Code: `4`
     */
    APIErrorCode[APIErrorCode["SIGNATURE"] = 4] = "SIGNATURE";
    /**
     * User authorization failed
     *
     * Code: `5`
     */
    APIErrorCode[APIErrorCode["AUTH"] = 5] = "AUTH";
    /**
     * Too many requests per second
     *
     * Code: `6`
     */
    APIErrorCode[APIErrorCode["TOO_MANY"] = 6] = "TOO_MANY";
    /**
     * Permission to perform this action is denied
     *
     * Code: `7`
     */
    APIErrorCode[APIErrorCode["PERMISSION"] = 7] = "PERMISSION";
    /**
     * Invalid request
     *
     * Code: `8`
     */
    APIErrorCode[APIErrorCode["REQUEST"] = 8] = "REQUEST";
    /**
     * Flood control
     *
     * Code: `9`
     */
    APIErrorCode[APIErrorCode["FLOOD"] = 9] = "FLOOD";
    /**
     * Internal server error
     *
     * Code: `10`
     */
    APIErrorCode[APIErrorCode["SERVER"] = 10] = "SERVER";
    /**
     * In test mode application should be disabled or user should be authorized
     *
     * Code: `11`
     */
    APIErrorCode[APIErrorCode["ENABLED_IN_TEST"] = 11] = "ENABLED_IN_TEST";
    /**
     * Unable to compile code
     *
     * Code: `12`
     */
    APIErrorCode[APIErrorCode["COMPILE"] = 12] = "COMPILE";
    /**
     * Runtime error occurred during code invocation
     *
     * Code: `13`
     */
    APIErrorCode[APIErrorCode["RUNTIME"] = 13] = "RUNTIME";
    /**
     * Captcha needed
     *
     * Code: `14`
     */
    APIErrorCode[APIErrorCode["CAPTCHA"] = 14] = "CAPTCHA";
    /**
     * Access denied
     *
     * Code: `15`
     */
    APIErrorCode[APIErrorCode["ACCESS"] = 15] = "ACCESS";
    /**
     * HTTP authorization failed
     *
     * Code: `16`
     */
    APIErrorCode[APIErrorCode["AUTH_HTTPS"] = 16] = "AUTH_HTTPS";
    /**
     * Validation required
     *
     * Code: `17`
     */
    APIErrorCode[APIErrorCode["AUTH_VALIDATION"] = 17] = "AUTH_VALIDATION";
    /**
     * User was deleted or banned
     *
     * Code: `18`
     */
    APIErrorCode[APIErrorCode["USER_DELETED"] = 18] = "USER_DELETED";
    /**
     * Content blocked
     *
     * Code: `19`
     */
    APIErrorCode[APIErrorCode["BLOCKED"] = 19] = "BLOCKED";
    /**
     * Permission to perform this action is denied for non-standalone applications
     *
     * Code: `20`
     */
    APIErrorCode[APIErrorCode["METHOD_PERMISSION"] = 20] = "METHOD_PERMISSION";
    /**
     * Permission to perform this action is allowed only for standalone and OpenAPI applications
     *
     * Code: `21`
     */
    APIErrorCode[APIErrorCode["METHOD_ADS"] = 21] = "METHOD_ADS";
    /**
     * Upload error
     *
     * Code: `22`
     */
    APIErrorCode[APIErrorCode["UPLOAD"] = 22] = "UPLOAD";
    /**
     * This method was disabled
     *
     * Code: `23`
     */
    APIErrorCode[APIErrorCode["METHOD_DISABLED"] = 23] = "METHOD_DISABLED";
    /**
     * Confirmation required
     *
     * Code: `24`
     */
    APIErrorCode[APIErrorCode["NEED_CONFIRMATION"] = 24] = "NEED_CONFIRMATION";
    /**
     * Token confirmation required
     *
     * Code: `25`
     */
    APIErrorCode[APIErrorCode["NEED_TOKEN_CONFIRMATION"] = 25] = "NEED_TOKEN_CONFIRMATION";
    /**
     * Group authorization failed
     *
     * Code: `27`
     */
    APIErrorCode[APIErrorCode["GROUP_AUTH"] = 27] = "GROUP_AUTH";
    /**
     * Application authorization failed
     *
     * Code: `28`
     */
    APIErrorCode[APIErrorCode["APP_AUTH"] = 28] = "APP_AUTH";
    /**
     * Rate limit reached
     *
     * Code: `29`
     */
    APIErrorCode[APIErrorCode["RATE_LIMIT"] = 29] = "RATE_LIMIT";
    /**
     * This profile is private
     *
     * Code: `30`
     */
    APIErrorCode[APIErrorCode["PRIVATE_PROFILE"] = 30] = "PRIVATE_PROFILE";
    /**
     * Not implemented yet
     *
     * Code: `33`
     */
    APIErrorCode[APIErrorCode["NOT_IMPLEMENTED_YET"] = 33] = "NOT_IMPLEMENTED_YET";
    /**
     * Client version deprecated
     *
     * Code: `34`
     */
    APIErrorCode[APIErrorCode["CLIENT_VERSION_DEPRECATED"] = 34] = "CLIENT_VERSION_DEPRECATED";
    /**
     * Client update needed
     *
     * Code: `35`
     */
    APIErrorCode[APIErrorCode["CLIENT_UPDATE_NEEDED"] = 35] = "CLIENT_UPDATE_NEEDED";
    /**
     * Method execution was interrupted due to timeout
     *
     * Code: `36`
     */
    APIErrorCode[APIErrorCode["TIMEOUT"] = 36] = "TIMEOUT";
    /**
     * User was banned
     *
     * Code: `37`
     */
    APIErrorCode[APIErrorCode["USER_BANNED"] = 37] = "USER_BANNED";
    /**
     * Unknown application
     *
     * Code: `38`
     */
    APIErrorCode[APIErrorCode["UNKNOWN_APPLICATION"] = 38] = "UNKNOWN_APPLICATION";
    /**
     * Unknown user
     *
     * Code: `39`
     */
    APIErrorCode[APIErrorCode["UNKNOWN_USER"] = 39] = "UNKNOWN_USER";
    /**
     * Unknown group
     *
     * Code: `40`
     */
    APIErrorCode[APIErrorCode["UNKNOWN_GROUP"] = 40] = "UNKNOWN_GROUP";
    /**
     * Additional signup required
     *
     * Code: `41`
     */
    APIErrorCode[APIErrorCode["ADDITIONAL_SIGNUP_REQUIRED"] = 41] = "ADDITIONAL_SIGNUP_REQUIRED";
    /**
     * IP is not allowed
     *
     * Code: `42`
     */
    APIErrorCode[APIErrorCode["IP_IS_NOT_ALLOWED"] = 42] = "IP_IS_NOT_ALLOWED";
    /**
     * One of the parameters specified was missing or invalid
     *
     * Code: `100`
     */
    APIErrorCode[APIErrorCode["PARAM"] = 100] = "PARAM";
    /**
     * Invalid application API ID
     *
     * Code: `101`
     */
    APIErrorCode[APIErrorCode["PARAM_API_ID"] = 101] = "PARAM_API_ID";
    /**
     * Out of limits
     *
     * Code: `103`
     */
    APIErrorCode[APIErrorCode["LIMITS"] = 103] = "LIMITS";
    /**
     * Not found
     *
     * Code: `104`
     */
    APIErrorCode[APIErrorCode["NOT_FOUND"] = 104] = "NOT_FOUND";
    /**
     * Couldn't save file
     *
     * Code: `105`
     */
    APIErrorCode[APIErrorCode["SAVE_FILE"] = 105] = "SAVE_FILE";
    /**
     * Unable to process action
     *
     * Code: `106`
     */
    APIErrorCode[APIErrorCode["ACTION_FAILED"] = 106] = "ACTION_FAILED";
    /**
     * Invalid user id
     *
     * Code: `113`
     */
    APIErrorCode[APIErrorCode["PARAM_USER_ID"] = 113] = "PARAM_USER_ID";
    /**
     * Invalid album id
     *
     * Code: `114`
     */
    APIErrorCode[APIErrorCode["PARAM_ALBUM_ID"] = 114] = "PARAM_ALBUM_ID";
    /**
     * Invalid server
     *
     * Code: `118`
     */
    APIErrorCode[APIErrorCode["PARAM_SERVER"] = 118] = "PARAM_SERVER";
    /**
     * Invalid title
     *
     * Code: `119`
     */
    APIErrorCode[APIErrorCode["PARAM_TITLE"] = 119] = "PARAM_TITLE";
    /**
     * Invalid hash
     *
     * Code: `121`
     */
    APIErrorCode[APIErrorCode["PARAM_HASH"] = 121] = "PARAM_HASH";
    /**
     * Invalid photos
     *
     * Code: `122`
     */
    APIErrorCode[APIErrorCode["PARAM_PHOTOS"] = 122] = "PARAM_PHOTOS";
    /**
     * Invalid group id
     *
     * Code: `125`
     */
    APIErrorCode[APIErrorCode["PARAM_GROUP_ID"] = 125] = "PARAM_GROUP_ID";
    /**
     * Invalid photo
     *
     * Code: `129`
     */
    APIErrorCode[APIErrorCode["PARAM_PHOTO"] = 129] = "PARAM_PHOTO";
    /**
     * Page not found
     *
     * Code: `140`
     */
    APIErrorCode[APIErrorCode["PARAM_PAGE_ID"] = 140] = "PARAM_PAGE_ID";
    /**
     * Access to page denied
     *
     * Code: `141`
     */
    APIErrorCode[APIErrorCode["ACCESS_PAGE"] = 141] = "ACCESS_PAGE";
    /**
     * The mobile number of the user is unknown
     *
     * Code: `146`
     */
    APIErrorCode[APIErrorCode["MOBILE_NOT_ACTIVATED"] = 146] = "MOBILE_NOT_ACTIVATED";
    /**
     * Application has insufficient funds
     *
     * Code: `147`
     */
    APIErrorCode[APIErrorCode["INSUFFICIENT_FUNDS"] = 147] = "INSUFFICIENT_FUNDS";
    /**
     * Invalid timestamp
     *
     * Code: `150`
     */
    APIErrorCode[APIErrorCode["PARAM_TIMESTAMP"] = 150] = "PARAM_TIMESTAMP";
    /**
     * Invalid list id
     *
     * Code: `171`
     */
    APIErrorCode[APIErrorCode["FRIENDS_LIST_ID"] = 171] = "FRIENDS_LIST_ID";
    /**
     * Reached the maximum number of lists
     *
     * Code: `173`
     */
    APIErrorCode[APIErrorCode["FRIENDS_LIST_LIMIT"] = 173] = "FRIENDS_LIST_LIMIT";
    /**
     * Cannot add user himself as friend
     *
     * Code: `174`
     */
    APIErrorCode[APIErrorCode["FRIENDS_ADD_YOURSELF"] = 174] = "FRIENDS_ADD_YOURSELF";
    /**
     * Cannot add this user to friends as they have put you on their blacklist
     *
     * Code: `175`
     */
    APIErrorCode[APIErrorCode["FRIENDS_ADD_IN_ENEMY"] = 175] = "FRIENDS_ADD_IN_ENEMY";
    /**
     * Cannot add this user to friends as you put him on blacklist
     *
     * Code: `176`
     */
    APIErrorCode[APIErrorCode["FRIENDS_ADD_ENEMY"] = 176] = "FRIENDS_ADD_ENEMY";
    /**
     * Cannot add this user to friends as user not found
     *
     * Code: `177`
     */
    APIErrorCode[APIErrorCode["FRIENDS_ADD_NOT_FOUND"] = 177] = "FRIENDS_ADD_NOT_FOUND";
    /**
     * Note not found
     *
     * Code: `180`
     */
    APIErrorCode[APIErrorCode["PARAM_NOTE_ID"] = 180] = "PARAM_NOTE_ID";
    /**
     * Access to note denied
     *
     * Code: `181`
     */
    APIErrorCode[APIErrorCode["ACCESS_NOTE"] = 181] = "ACCESS_NOTE";
    /**
     * You can't comment this note
     *
     * Code: `182`
     */
    APIErrorCode[APIErrorCode["ACCESS_NOTE_COMMENT"] = 182] = "ACCESS_NOTE_COMMENT";
    /**
     * Access to comment denied
     *
     * Code: `183`
     */
    APIErrorCode[APIErrorCode["ACCESS_COMMENT"] = 183] = "ACCESS_COMMENT";
    /**
     * Access denied
     *
     * Code: `200`
     */
    APIErrorCode[APIErrorCode["ACCESS_ALBUM"] = 200] = "ACCESS_ALBUM";
    /**
     * Access denied
     *
     * Code: `201`
     */
    APIErrorCode[APIErrorCode["ACCESS_AUDIO"] = 201] = "ACCESS_AUDIO";
    /**
     * Access to group denied
     *
     * Code: `203`
     */
    APIErrorCode[APIErrorCode["ACCESS_GROUP"] = 203] = "ACCESS_GROUP";
    /**
     * Access denied
     *
     * Code: `204`
     */
    APIErrorCode[APIErrorCode["ACCESS_VIDEO"] = 204] = "ACCESS_VIDEO";
    /**
     * Access denied
     *
     * Code: `205`
     */
    APIErrorCode[APIErrorCode["ACCESS_MARKET"] = 205] = "ACCESS_MARKET";
    /**
     * Access to wall's post denied
     *
     * Code: `210`
     */
    APIErrorCode[APIErrorCode["WALL_ACCESS_POST"] = 210] = "WALL_ACCESS_POST";
    /**
     * Access to wall's comment denied
     *
     * Code: `211`
     */
    APIErrorCode[APIErrorCode["WALL_ACCESS_COMMENT"] = 211] = "WALL_ACCESS_COMMENT";
    /**
     * Access to post comments denied
     *
     * Code: `212`
     */
    APIErrorCode[APIErrorCode["WALL_ACCESS_REPLIES"] = 212] = "WALL_ACCESS_REPLIES";
    /**
     * Access to status replies denied
     *
     * Code: `213`
     */
    APIErrorCode[APIErrorCode["WALL_ACCESS_ADD_REPLY"] = 213] = "WALL_ACCESS_ADD_REPLY";
    /**
     * Access to adding post denied
     *
     * Code: `214`
     */
    APIErrorCode[APIErrorCode["WALL_ADD_POST"] = 214] = "WALL_ADD_POST";
    /**
     * Advertisement post was recently added
     *
     * Code: `219`
     */
    APIErrorCode[APIErrorCode["WALL_ADS_PUBLISHED"] = 219] = "WALL_ADS_PUBLISHED";
    /**
     * Too many recipients
     *
     * Code: `220`
     */
    APIErrorCode[APIErrorCode["WALL_TOO_MANY_RECIPIENTS"] = 220] = "WALL_TOO_MANY_RECIPIENTS";
    /**
     * User disabled track name broadcast
     *
     * Code: `221`
     */
    APIErrorCode[APIErrorCode["STATUS_NO_AUDIO"] = 221] = "STATUS_NO_AUDIO";
    /**
     * Hyperlinks are forbidden
     *
     * Code: `222`
     */
    APIErrorCode[APIErrorCode["WALL_LINKS_FORBIDDEN"] = 222] = "WALL_LINKS_FORBIDDEN";
    /**
     * Too many replies
     *
     * Code: `223`
     */
    APIErrorCode[APIErrorCode["WALL_REPLY_OWNER_FLOOD"] = 223] = "WALL_REPLY_OWNER_FLOOD";
    /**
     * Too many ads posts
     *
     * Code: `224`
     */
    APIErrorCode[APIErrorCode["WALL_ADS_POST_LIMIT_REACHED"] = 224] = "WALL_ADS_POST_LIMIT_REACHED";
    /**
     * Donut is disabled
     *
     * Code: `225`
     */
    APIErrorCode[APIErrorCode["WALL_DONUT"] = 225] = "WALL_DONUT";
    /**
     * Reaction can not be applied to the object
     *
     * Code: `232`
     */
    APIErrorCode[APIErrorCode["LIKES_REACTION_CAN_NOT_BE_APPLIED"] = 232] = "LIKES_REACTION_CAN_NOT_BE_APPLIED";
    /**
     * Access to poll denied
     *
     * Code: `250`
     */
    APIErrorCode[APIErrorCode["POLLS_ACCESS"] = 250] = "POLLS_ACCESS";
    /**
     * Invalid poll id
     *
     * Code: `251`
     */
    APIErrorCode[APIErrorCode["POLLS_POLL_ID"] = 251] = "POLLS_POLL_ID";
    /**
     * Invalid answer id
     *
     * Code: `252`
     */
    APIErrorCode[APIErrorCode["POLLS_ANSWER_ID"] = 252] = "POLLS_ANSWER_ID";
    /**
     * Access denied, please vote first
     *
     * Code: `253`
     */
    APIErrorCode[APIErrorCode["POLLS_ACCESS_WITHOUT_VOTE"] = 253] = "POLLS_ACCESS_WITHOUT_VOTE";
    /**
     * Access to the groups list is denied due to the user's privacy settings
     *
     * Code: `260`
     */
    APIErrorCode[APIErrorCode["ACCESS_GROUPS"] = 260] = "ACCESS_GROUPS";
    /**
     * This album is full
     *
     * Code: `300`
     */
    APIErrorCode[APIErrorCode["ALBUM_FULL"] = 300] = "ALBUM_FULL";
    /**
     * Albums number limit is reached
     *
     * Code: `302`
     */
    APIErrorCode[APIErrorCode["ALBUMS_LIMIT"] = 302] = "ALBUMS_LIMIT";
    /**
     * Permission denied. You must enable votes processing in application settings
     *
     * Code: `500`
     */
    APIErrorCode[APIErrorCode["VOTES_PERMISSION"] = 500] = "VOTES_PERMISSION";
    /**
     * Permission denied. You have no access to operations specified with given object(s)
     *
     * Code: `600`
     */
    APIErrorCode[APIErrorCode["ADS_PERMISSION"] = 600] = "ADS_PERMISSION";
    /**
     * Permission denied. You have requested too many actions this day. Try later.
     *
     * Code: `601`
     */
    APIErrorCode[APIErrorCode["WEIGHTED_FLOOD"] = 601] = "WEIGHTED_FLOOD";
    /**
     * Some part of the request has not been completed
     *
     * Code: `602`
     */
    APIErrorCode[APIErrorCode["ADS_PARTIAL_SUCCESS"] = 602] = "ADS_PARTIAL_SUCCESS";
    /**
     * Some ads error occurs
     *
     * Code: `603`
     */
    APIErrorCode[APIErrorCode["ADS_SPECIFIC"] = 603] = "ADS_SPECIFIC";
    /**
     * Object deleted
     *
     * Code: `629`
     */
    APIErrorCode[APIErrorCode["ADS_OBJECT_DELETED"] = 629] = "ADS_OBJECT_DELETED";
    /**
     * Cannot edit creator role
     *
     * Code: `700`
     */
    APIErrorCode[APIErrorCode["GROUP_CHANGE_CREATOR"] = 700] = "GROUP_CHANGE_CREATOR";
    /**
     * User should be in club
     *
     * Code: `701`
     */
    APIErrorCode[APIErrorCode["GROUP_NOT_IN_CLUB"] = 701] = "GROUP_NOT_IN_CLUB";
    /**
     * Too many officers in club
     *
     * Code: `702`
     */
    APIErrorCode[APIErrorCode["GROUP_TOO_MANY_OFFICERS"] = 702] = "GROUP_TOO_MANY_OFFICERS";
    /**
     * You need to enable 2FA for this action
     *
     * Code: `703`
     */
    APIErrorCode[APIErrorCode["GROUP_NEED_2FA"] = 703] = "GROUP_NEED_2FA";
    /**
     * User needs to enable 2FA for this action
     *
     * Code: `704`
     */
    APIErrorCode[APIErrorCode["GROUP_HOST_NEED_2FA"] = 704] = "GROUP_HOST_NEED_2FA";
    /**
     * Too many addresses in club
     *
     * Code: `706`
     */
    APIErrorCode[APIErrorCode["GROUP_TOO_MANY_ADDRESSES"] = 706] = "GROUP_TOO_MANY_ADDRESSES";
    /**
     * Application is not installed in community
     *
     * Code: `711`
     */
    APIErrorCode[APIErrorCode["GROUP_APP_IS_NOT_INSTALLED_IN_COMMUNITY"] = 711] = "GROUP_APP_IS_NOT_INSTALLED_IN_COMMUNITY";
    /**
     * Invite link is invalid - expired, deleted or not exists
     *
     * Code: `714`
     */
    APIErrorCode[APIErrorCode["GROUP_INVITE_LINKS_NOT_VALID"] = 714] = "GROUP_INVITE_LINKS_NOT_VALID";
    /**
     * This video is already added
     *
     * Code: `800`
     */
    APIErrorCode[APIErrorCode["VIDEO_ALREADY_ADDED"] = 800] = "VIDEO_ALREADY_ADDED";
    /**
     * Comments for this video are closed
     *
     * Code: `801`
     */
    APIErrorCode[APIErrorCode["VIDEO_COMMENTS_CLOSED"] = 801] = "VIDEO_COMMENTS_CLOSED";
    /**
     * Can't send messages for users from blacklist
     *
     * Code: `900`
     */
    APIErrorCode[APIErrorCode["MESSAGES_USER_BLOCKED"] = 900] = "MESSAGES_USER_BLOCKED";
    /**
     * Can't send messages for users without permission
     *
     * Code: `901`
     */
    APIErrorCode[APIErrorCode["MESSAGES_DENY_SEND"] = 901] = "MESSAGES_DENY_SEND";
    /**
     * Can't send messages to this user due to their privacy settings
     *
     * Code: `902`
     */
    APIErrorCode[APIErrorCode["MESSAGES_PRIVACY"] = 902] = "MESSAGES_PRIVACY";
    /**
     * Value of ts or pts is too old
     *
     * Code: `907`
     */
    APIErrorCode[APIErrorCode["MESSAGES_TOO_OLD_PTS"] = 907] = "MESSAGES_TOO_OLD_PTS";
    /**
     * Value of ts or pts is too new
     *
     * Code: `908`
     */
    APIErrorCode[APIErrorCode["MESSAGES_TOO_NEW_PTS"] = 908] = "MESSAGES_TOO_NEW_PTS";
    /**
     * Can't edit this message, because it's too old
     *
     * Code: `909`
     */
    APIErrorCode[APIErrorCode["MESSAGES_EDIT_EXPIRED"] = 909] = "MESSAGES_EDIT_EXPIRED";
    /**
     * Can't send this message, because it's too big
     *
     * Code: `910`
     */
    APIErrorCode[APIErrorCode["MESSAGES_TOO_BIG"] = 910] = "MESSAGES_TOO_BIG";
    /**
     * Keyboard format is invalid
     *
     * Code: `911`
     */
    APIErrorCode[APIErrorCode["MESSAGES_KEYBOARD_INVALID"] = 911] = "MESSAGES_KEYBOARD_INVALID";
    /**
     * This is a chat bot feature, change this status in settings
     *
     * Code: `912`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CHAT_BOT_FEATURE"] = 912] = "MESSAGES_CHAT_BOT_FEATURE";
    /**
     * Too many forwarded messages
     *
     * Code: `913`
     */
    APIErrorCode[APIErrorCode["MESSAGES_TOO_LONG_FORWARDS"] = 913] = "MESSAGES_TOO_LONG_FORWARDS";
    /**
     * Message is too long
     *
     * Code: `914`
     */
    APIErrorCode[APIErrorCode["MESSAGES_TOO_LONG_MESSAGE"] = 914] = "MESSAGES_TOO_LONG_MESSAGE";
    /**
     * You don't have access to this chat
     *
     * Code: `917`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CHAT_USER_NO_ACCESS"] = 917] = "MESSAGES_CHAT_USER_NO_ACCESS";
    /**
     * You can't see invite link for this chat
     *
     * Code: `919`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CANT_SEE_INVITE_LINK"] = 919] = "MESSAGES_CANT_SEE_INVITE_LINK";
    /**
     * Can't edit this kind of message
     *
     * Code: `920`
     */
    APIErrorCode[APIErrorCode["MESSAGES_EDIT_KIND_DISALLOWED"] = 920] = "MESSAGES_EDIT_KIND_DISALLOWED";
    /**
     * Can't forward these messages
     *
     * Code: `921`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CANT_FWD"] = 921] = "MESSAGES_CANT_FWD";
    /**
     * Can't delete this message for everybody
     *
     * Code: `924`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CANT_DELETE_FOR_ALL"] = 924] = "MESSAGES_CANT_DELETE_FOR_ALL";
    /**
     * You are not admin of this chat
     *
     * Code: `925`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CHAT_NOT_ADMIN"] = 925] = "MESSAGES_CHAT_NOT_ADMIN";
    /**
     * Chat does not exist
     *
     * Code: `927`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CHAT_NOT_EXIST"] = 927] = "MESSAGES_CHAT_NOT_EXIST";
    /**
     * You can't change invite link for this chat
     *
     * Code: `931`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CANT_CHANGE_INVITE_LINK"] = 931] = "MESSAGES_CANT_CHANGE_INVITE_LINK";
    /**
     * Your community can't interact with this peer
     *
     * Code: `932`
     */
    APIErrorCode[APIErrorCode["MESSAGES_GROUP_PEER_ACCESS"] = 932] = "MESSAGES_GROUP_PEER_ACCESS";
    /**
     * User not found in chat
     *
     * Code: `935`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CHAT_USER_NOT_IN_CHAT"] = 935] = "MESSAGES_CHAT_USER_NOT_IN_CHAT";
    /**
     * Contact not found
     *
     * Code: `936`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CONTACT_NOT_FOUND"] = 936] = "MESSAGES_CONTACT_NOT_FOUND";
    /**
     * Message request already sent
     *
     * Code: `939`
     */
    APIErrorCode[APIErrorCode["MESSAGES_MESSAGE_REQUEST_ALREADY_SENT"] = 939] = "MESSAGES_MESSAGE_REQUEST_ALREADY_SENT";
    /**
     * Too many posts in messages
     *
     * Code: `940`
     */
    APIErrorCode[APIErrorCode["MESSAGES_TOO_MANY_POSTS"] = 940] = "MESSAGES_TOO_MANY_POSTS";
    /**
     * Cannot pin one-time story
     *
     * Code: `942`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CANT_PIN_ONE_TIME_STORY"] = 942] = "MESSAGES_CANT_PIN_ONE_TIME_STORY";
    /**
     * Cannot use this intent
     *
     * Code: `943`
     */
    APIErrorCode[APIErrorCode["MESSAGES_INTENT_CANT_USE"] = 943] = "MESSAGES_INTENT_CANT_USE";
    /**
     * Limits overflow for this intent
     *
     * Code: `944`
     */
    APIErrorCode[APIErrorCode["MESSAGES_INTENT_LIMIT_OVERFLOW"] = 944] = "MESSAGES_INTENT_LIMIT_OVERFLOW";
    /**
     * Chat was disabled
     *
     * Code: `945`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CHAT_DISABLED"] = 945] = "MESSAGES_CHAT_DISABLED";
    /**
     * Chat not supported
     *
     * Code: `946`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CHAT_UNSUPPORTED"] = 946] = "MESSAGES_CHAT_UNSUPPORTED";
    /**
     * Can't add user to chat, because user has no access to group
     *
     * Code: `947`
     */
    APIErrorCode[APIErrorCode["MESSAGES_MEMBER_ACCESS_TO_GROUP_DENIED"] = 947] = "MESSAGES_MEMBER_ACCESS_TO_GROUP_DENIED";
    /**
     * Can't edit pinned message yet
     *
     * Code: `949`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CANT_EDIT_PINNED_YET"] = 949] = "MESSAGES_CANT_EDIT_PINNED_YET";
    /**
     * Can't send message, reply timed out
     *
     * Code: `950`
     */
    APIErrorCode[APIErrorCode["MESSAGES_PEER_BLOCKED_REASON_BY_TIME"] = 950] = "MESSAGES_PEER_BLOCKED_REASON_BY_TIME";
    /**
     * You can't access donut chat without subscription
     *
     * Code: `962`
     */
    APIErrorCode[APIErrorCode["MESSAGES_USER_NOT_DON"] = 962] = "MESSAGES_USER_NOT_DON";
    /**
     * Message cannot be forwarded
     *
     * Code: `969`
     */
    APIErrorCode[APIErrorCode["MESSAGES_MESSAGE_CANNOT_BE_FORWARDED"] = 969] = "MESSAGES_MESSAGE_CANNOT_BE_FORWARDED";
    /**
     * Cannot pin an expiring message
     *
     * Code: `970`
     */
    APIErrorCode[APIErrorCode["MESSAGES_CANT_PIN_EXPIRING_MESSAGE"] = 970] = "MESSAGES_CANT_PIN_EXPIRING_MESSAGE";
    /**
     * Too many auth attempts, try again later
     *
     * Code: `1105`
     */
    APIErrorCode[APIErrorCode["AUTH_FLOOD_ERROR"] = 1105] = "AUTH_FLOOD_ERROR";
    /**
     * Anonymous token has expired
     *
     * Code: `1114`
     */
    APIErrorCode[APIErrorCode["AUTH_ANONYMOUS_TOKEN_HAS_EXPIRED"] = 1114] = "AUTH_ANONYMOUS_TOKEN_HAS_EXPIRED";
    /**
     * Anonymous token is invalid
     *
     * Code: `1116`
     */
    APIErrorCode[APIErrorCode["AUTH_ANONYMOUS_TOKEN_IS_INVALID"] = 1116] = "AUTH_ANONYMOUS_TOKEN_IS_INVALID";
    /**
     * Invalid document id
     *
     * Code: `1150`
     */
    APIErrorCode[APIErrorCode["PARAM_DOC_ID"] = 1150] = "PARAM_DOC_ID";
    /**
     * Access to document deleting is denied
     *
     * Code: `1151`
     */
    APIErrorCode[APIErrorCode["PARAM_DOC_DELETE_ACCESS"] = 1151] = "PARAM_DOC_DELETE_ACCESS";
    /**
     * Invalid document title
     *
     * Code: `1152`
     */
    APIErrorCode[APIErrorCode["PARAM_DOC_TITLE"] = 1152] = "PARAM_DOC_TITLE";
    /**
     * Access to document is denied
     *
     * Code: `1153`
     */
    APIErrorCode[APIErrorCode["PARAM_DOC_ACCESS"] = 1153] = "PARAM_DOC_ACCESS";
    /**
     * Original photo was changed
     *
     * Code: `1160`
     */
    APIErrorCode[APIErrorCode["PHOTO_CHANGED"] = 1160] = "PHOTO_CHANGED";
    /**
     * Too many feed lists
     *
     * Code: `1170`
     */
    APIErrorCode[APIErrorCode["TOO_MANY_LISTS"] = 1170] = "TOO_MANY_LISTS";
    /**
     * This achievement is already unlocked
     *
     * Code: `1251`
     */
    APIErrorCode[APIErrorCode["APPS_ALREADY_UNLOCKED"] = 1251] = "APPS_ALREADY_UNLOCKED";
    /**
     * Subscription not found
     *
     * Code: `1256`
     */
    APIErrorCode[APIErrorCode["APPS_SUBSCRIPTION_NOT_FOUND"] = 1256] = "APPS_SUBSCRIPTION_NOT_FOUND";
    /**
     * Subscription is in invalid status
     *
     * Code: `1257`
     */
    APIErrorCode[APIErrorCode["APPS_SUBSCRIPTION_INVALID_STATUS"] = 1257] = "APPS_SUBSCRIPTION_INVALID_STATUS";
    /**
     * Invalid screen name
     *
     * Code: `1260`
     */
    APIErrorCode[APIErrorCode["INVALID_ADDRESS"] = 1260] = "INVALID_ADDRESS";
    /**
     * Catalog is not available for this user
     *
     * Code: `1310`
     */
    APIErrorCode[APIErrorCode["COMMUNITIES_CATALOG_DISABLED"] = 1310] = "COMMUNITIES_CATALOG_DISABLED";
    /**
     * Catalog categories are not available for this user
     *
     * Code: `1311`
     */
    APIErrorCode[APIErrorCode["COMMUNITIES_CATEGORIES_DISABLED"] = 1311] = "COMMUNITIES_CATEGORIES_DISABLED";
    /**
     * Too late for restore
     *
     * Code: `1400`
     */
    APIErrorCode[APIErrorCode["MARKET_RESTORE_TOO_LATE"] = 1400] = "MARKET_RESTORE_TOO_LATE";
    /**
     * Comments for this market are closed
     *
     * Code: `1401`
     */
    APIErrorCode[APIErrorCode["MARKET_COMMENTS_CLOSED"] = 1401] = "MARKET_COMMENTS_CLOSED";
    /**
     * Album not found
     *
     * Code: `1402`
     */
    APIErrorCode[APIErrorCode["MARKET_ALBUM_NOT_FOUND"] = 1402] = "MARKET_ALBUM_NOT_FOUND";
    /**
     * Item not found
     *
     * Code: `1403`
     */
    APIErrorCode[APIErrorCode["MARKET_ITEM_NOT_FOUND"] = 1403] = "MARKET_ITEM_NOT_FOUND";
    /**
     * Item already added to album
     *
     * Code: `1404`
     */
    APIErrorCode[APIErrorCode["MARKET_ITEM_ALREADY_ADDED"] = 1404] = "MARKET_ITEM_ALREADY_ADDED";
    /**
     * Too many items
     *
     * Code: `1405`
     */
    APIErrorCode[APIErrorCode["MARKET_TOO_MANY_ITEMS"] = 1405] = "MARKET_TOO_MANY_ITEMS";
    /**
     * Too many items in album
     *
     * Code: `1406`
     */
    APIErrorCode[APIErrorCode["MARKET_TOO_MANY_ITEMS_IN_ALBUM"] = 1406] = "MARKET_TOO_MANY_ITEMS_IN_ALBUM";
    /**
     * Too many albums
     *
     * Code: `1407`
     */
    APIErrorCode[APIErrorCode["MARKET_TOO_MANY_ALBUMS"] = 1407] = "MARKET_TOO_MANY_ALBUMS";
    /**
     * Item has bad links in description
     *
     * Code: `1408`
     */
    APIErrorCode[APIErrorCode["MARKET_ITEM_HAS_BAD_LINKS"] = 1408] = "MARKET_ITEM_HAS_BAD_LINKS";
    /**
     * Extended market not enabled
     *
     * Code: `1409`
     */
    APIErrorCode[APIErrorCode["MARKET_EXTENDED_NOT_ENABLED"] = 1409] = "MARKET_EXTENDED_NOT_ENABLED";
    /**
     * Grouping items with different properties
     *
     * Code: `1412`
     */
    APIErrorCode[APIErrorCode["MARKET_GROUPING_ITEMS_WITH_DIFFERENT_PROPERTIES"] = 1412] = "MARKET_GROUPING_ITEMS_WITH_DIFFERENT_PROPERTIES";
    /**
     * Grouping already has such variant
     *
     * Code: `1413`
     */
    APIErrorCode[APIErrorCode["MARKET_GROUPING_ALREADY_HAS_SUCH_VARIANT"] = 1413] = "MARKET_GROUPING_ALREADY_HAS_SUCH_VARIANT";
    /**
     * Variant not found
     *
     * Code: `1416`
     */
    APIErrorCode[APIErrorCode["MARKET_VARIANT_NOT_FOUND"] = 1416] = "MARKET_VARIANT_NOT_FOUND";
    /**
     * Property not found
     *
     * Code: `1417`
     */
    APIErrorCode[APIErrorCode["MARKET_PROPERTY_NOT_FOUND"] = 1417] = "MARKET_PROPERTY_NOT_FOUND";
    /**
     * Grouping must have two or more items
     *
     * Code: `1425`
     */
    APIErrorCode[APIErrorCode["MARKET_GROUPING_MUST_CONTAIN_MORE_THAN_ONE_ITEM"] = 1425] = "MARKET_GROUPING_MUST_CONTAIN_MORE_THAN_ONE_ITEM";
    /**
     * Item must have distinct properties
     *
     * Code: `1426`
     */
    APIErrorCode[APIErrorCode["MARKET_GROUPING_ITEMS_MUST_HAVE_DISTINCT_PROPERTIES"] = 1426] = "MARKET_GROUPING_ITEMS_MUST_HAVE_DISTINCT_PROPERTIES";
    /**
     * Cart is empty
     *
     * Code: `1427`
     */
    APIErrorCode[APIErrorCode["MARKET_ORDERS_NO_CART_ITEMS"] = 1427] = "MARKET_ORDERS_NO_CART_ITEMS";
    /**
     * Specify width, length, height and weight all together
     *
     * Code: `1429`
     */
    APIErrorCode[APIErrorCode["MARKET_INVALID_DIMENSIONS"] = 1429] = "MARKET_INVALID_DIMENSIONS";
    /**
     * VK Pay status can not be changed
     *
     * Code: `1430`
     */
    APIErrorCode[APIErrorCode["MARKET_CANT_CHANGE_VKPAY_STATUS"] = 1430] = "MARKET_CANT_CHANGE_VKPAY_STATUS";
    /**
     * Market was already enabled in this group
     *
     * Code: `1431`
     */
    APIErrorCode[APIErrorCode["MARKET_SHOP_ALREADY_ENABLED"] = 1431] = "MARKET_SHOP_ALREADY_ENABLED";
    /**
     * Market was already disabled in this group
     *
     * Code: `1432`
     */
    APIErrorCode[APIErrorCode["MARKET_SHOP_ALREADY_DISABLED"] = 1432] = "MARKET_SHOP_ALREADY_DISABLED";
    /**
     * Invalid image crop format
     *
     * Code: `1433`
     */
    APIErrorCode[APIErrorCode["MARKET_PHOTOS_CROP_INVALID_FORMAT"] = 1433] = "MARKET_PHOTOS_CROP_INVALID_FORMAT";
    /**
     * Crop bottom right corner is outside the image
     *
     * Code: `1434`
     */
    APIErrorCode[APIErrorCode["MARKET_PHOTOS_CROP_OVERFLOW"] = 1434] = "MARKET_PHOTOS_CROP_OVERFLOW";
    /**
     * Crop size is less than the minimum
     *
     * Code: `1435`
     */
    APIErrorCode[APIErrorCode["MARKET_PHOTOS_CROP_SIZE_TOO_LOW"] = 1435] = "MARKET_PHOTOS_CROP_SIZE_TOO_LOW";
    /**
     * Market not enabled
     *
     * Code: `1438`
     */
    APIErrorCode[APIErrorCode["MARKET_NOT_ENABLED"] = 1438] = "MARKET_NOT_ENABLED";
    /**
     * Main album can not be hidden
     *
     * Code: `1446`
     */
    APIErrorCode[APIErrorCode["MARKET_ALBUM_MAIN_HIDDEN"] = 1446] = "MARKET_ALBUM_MAIN_HIDDEN";
    /**
     * Story has already expired
     *
     * Code: `1600`
     */
    APIErrorCode[APIErrorCode["STORY_EXPIRED"] = 1600] = "STORY_EXPIRED";
    /**
     * Incorrect reply privacy
     *
     * Code: `1602`
     */
    APIErrorCode[APIErrorCode["STORY_INCORRECT_REPLY_PRIVACY"] = 1602] = "STORY_INCORRECT_REPLY_PRIVACY";
    /**
     * Card not found
     *
     * Code: `1900`
     */
    APIErrorCode[APIErrorCode["PRETTY_CARDS_CARD_NOT_FOUND"] = 1900] = "PRETTY_CARDS_CARD_NOT_FOUND";
    /**
     * Too many cards
     *
     * Code: `1901`
     */
    APIErrorCode[APIErrorCode["PRETTY_CARDS_TOO_MANY_CARDS"] = 1901] = "PRETTY_CARDS_TOO_MANY_CARDS";
    /**
     * Card is connected to post
     *
     * Code: `1902`
     */
    APIErrorCode[APIErrorCode["PRETTY_CARDS_CARD_IS_CONNECTED_TO_POST"] = 1902] = "PRETTY_CARDS_CARD_IS_CONNECTED_TO_POST";
    /**
     * Servers number limit is reached
     *
     * Code: `2000`
     */
    APIErrorCode[APIErrorCode["CALLBACK_API_SERVERS_LIMIT"] = 2000] = "CALLBACK_API_SERVERS_LIMIT";
    /**
     * Stickers are not purchased
     *
     * Code: `2100`
     */
    APIErrorCode[APIErrorCode["STICKERS_NOT_PURCHASED"] = 2100] = "STICKERS_NOT_PURCHASED";
    /**
     * Too many favorite stickers
     *
     * Code: `2101`
     */
    APIErrorCode[APIErrorCode["STICKERS_TOO_MANY_FAVORITES"] = 2101] = "STICKERS_TOO_MANY_FAVORITES";
    /**
     * Stickers are not favorite
     *
     * Code: `2102`
     */
    APIErrorCode[APIErrorCode["STICKERS_NOT_FAVORITE"] = 2102] = "STICKERS_NOT_FAVORITE";
    /**
     * Specified link is incorrect (can't find source)
     *
     * Code: `3102`
     */
    APIErrorCode[APIErrorCode["WALL_CHECK_LINK_CANT_DETERMINE_SOURCE"] = 3102] = "WALL_CHECK_LINK_CANT_DETERMINE_SOURCE";
    /**
     * Recaptcha needed
     *
     * Code: `3300`
     */
    APIErrorCode[APIErrorCode["RECAPTCHA"] = 3300] = "RECAPTCHA";
    /**
     * Phone validation needed
     *
     * Code: `3301`
     */
    APIErrorCode[APIErrorCode["PHONE_VALIDATION_NEED"] = 3301] = "PHONE_VALIDATION_NEED";
    /**
     * Password validation needed
     *
     * Code: `3302`
     */
    APIErrorCode[APIErrorCode["PASSWORD_VALIDATION_NEED"] = 3302] = "PASSWORD_VALIDATION_NEED";
    /**
     * Otp app validation needed
     *
     * Code: `3303`
     */
    APIErrorCode[APIErrorCode["OTP_VALIDATION_NEED"] = 3303] = "OTP_VALIDATION_NEED";
    /**
     * Email confirmation needed
     *
     * Code: `3304`
     */
    APIErrorCode[APIErrorCode["EMAIL_CONFIRMATION_NEED"] = 3304] = "EMAIL_CONFIRMATION_NEED";
    /**
     * Assert votes
     *
     * Code: `3305`
     */
    APIErrorCode[APIErrorCode["ASSERT_VOTES"] = 3305] = "ASSERT_VOTES";
    /**
     * Token extension required
     *
     * Code: `3609`
     */
    APIErrorCode[APIErrorCode["TOKEN_EXTENSION_REQUIRED"] = 3609] = "TOKEN_EXTENSION_REQUIRED";
    /**
     * User is deactivated
     *
     * Code: `3610`
     */
    APIErrorCode[APIErrorCode["USER_DEACTIVATED"] = 3610] = "USER_DEACTIVATED";
    /**
     * Service is deactivated for user
     *
     * Code: `3611`
     */
    APIErrorCode[APIErrorCode["USER_SERVICE_DEACTIVATED"] = 3611] = "USER_SERVICE_DEACTIVATED";
    /**
     * Can't set AliExpress tag to this type of object
     *
     * Code: `3800`
     */
    APIErrorCode[APIErrorCode["FAVE_ALIEXPRESS_TAG"] = 3800] = "FAVE_ALIEXPRESS_TAG";
})(exports.APIErrorCode || (exports.APIErrorCode = {}));

class APIError extends VKError {
    /**
     * Constructor
     */
    constructor(payload) {
        const code = Number(payload.error_code);
        const message = `Code №${code} - ${payload.error_msg}`;
        super({ code, message });
        this.params = payload.request_params;
        if (code === exports.APIErrorCode.CAPTCHA) {
            this.captchaSid = Number(payload.captcha_sid);
            this.captchaImg = payload.captcha_img;
        }
        else if (code === exports.APIErrorCode.AUTH_VALIDATION) {
            this.redirectUri = payload.redirect_uri;
        }
        else if (code === exports.APIErrorCode.NEED_CONFIRMATION) {
            this.confirmationText = payload.confirmation_text;
        }
    }
}

class UploadError extends VKError {
}

class CollectError extends VKError {
    /**
     * Constructor
     */
    constructor({ message, code, errors }) {
        super({ message, code });
        this.errors = errors;
    }
}

class UpdatesError extends VKError {
}

class ExecuteError extends APIError {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            error_code: options.error_code,
            error_msg: options.error_msg,
            request_params: []
        });
        this.method = options.method;
    }
}

class ResourceError extends VKError {
}

/**
 * Chat peer ID
 */
const PEER_CHAT_ID_OFFSET = 2e9;
/**
 * Minimum time interval api with error
 */
const MINIMUM_TIME_INTERVAL_API = 1133;
/**
 * The attachment types
 */
exports.AttachmentType = void 0;
(function (AttachmentType) {
    AttachmentType["ALBUM"] = "album";
    AttachmentType["AUDIO"] = "audio";
    AttachmentType["AUDIO_MESSAGE"] = "audio_message";
    AttachmentType["GRAFFITI"] = "graffiti";
    AttachmentType["DOCUMENT"] = "doc";
    AttachmentType["GIFT"] = "gift";
    AttachmentType["LINK"] = "link";
    AttachmentType["MARKET_ALBUM"] = "market_album";
    AttachmentType["MARKET"] = "market";
    AttachmentType["PHOTO"] = "photo";
    AttachmentType["STICKER"] = "sticker";
    AttachmentType["VIDEO"] = "video";
    AttachmentType["WALL_REPLY"] = "wall_reply";
    AttachmentType["WALL"] = "wall";
    AttachmentType["POLL"] = "poll";
    AttachmentType["PODCAST"] = "podcast";
    AttachmentType["STORY"] = "story";
    AttachmentType["TEXTLIVE"] = "textlive";
})(exports.AttachmentType || (exports.AttachmentType = {}));
/**
 * Default extensions for attachments
 */
var DefaultExtension;
(function (DefaultExtension) {
    DefaultExtension["photo"] = "jpg";
    DefaultExtension["video"] = "mp4";
    DefaultExtension["audio"] = "mp3";
    DefaultExtension["graffiti"] = "png";
    DefaultExtension["audioMessage"] = "ogg";
})(DefaultExtension || (DefaultExtension = {}));
/**
 * Default content type for attachments
 */
var DefaultContentType;
(function (DefaultContentType) {
    DefaultContentType["photo"] = "image/jpeg";
    DefaultContentType["video"] = "video/mp4";
    DefaultContentType["audio"] = "audio/mp3";
    DefaultContentType["graffiti"] = "image/png";
    DefaultContentType["audioMessage"] = "audio/ogg";
})(DefaultContentType || (DefaultContentType = {}));
/**
 * Sources of captcha
 */
exports.CaptchaType = void 0;
(function (CaptchaType) {
    CaptchaType["API"] = "API";
    CaptchaType["DIRECT_AUTH"] = "DIRECT_AUTH";
    CaptchaType["IMPLICIT_FLOW_AUTH"] = "IMPLICIT_FLOW_AUTH";
    CaptchaType["ACCOUNT_VERIFICATION"] = "ACCOUNT_VERIFICATION";
})(exports.CaptchaType || (exports.CaptchaType = {}));
/**
 * Message source
 */
exports.MessageSource = void 0;
(function (MessageSource) {
    MessageSource["USER"] = "user";
    MessageSource["CHAT"] = "chat";
    MessageSource["GROUP"] = "group";
    MessageSource["EMAIL"] = "email";
})(exports.MessageSource || (exports.MessageSource = {}));
/**
 * Resource types
 */
exports.ResourceType = void 0;
(function (ResourceType) {
    ResourceType["USER"] = "user";
    ResourceType["GROUP"] = "group";
    ResourceType["APPLICATION"] = "application";
})(exports.ResourceType || (exports.ResourceType = {}));
/**
 * Updates sources
 */
exports.UpdateSource = void 0;
(function (UpdateSource) {
    UpdateSource["POLLING"] = "POLLING";
    UpdateSource["WEBHOOK"] = "WEBHOOK";
    UpdateSource["WEBSOCKET"] = "WEBSOCKET";
})(exports.UpdateSource || (exports.UpdateSource = {}));
/**
 * Upload error codes
 */
exports.UploadErrorCode = void 0;
(function (UploadErrorCode) {
    UploadErrorCode["MISSING_PARAMETERS"] = "MISSING_PARAMETERS";
    UploadErrorCode["NO_FILES_TO_UPLOAD"] = "NO_FILES_TO_UPLOAD";
    UploadErrorCode["EXCEEDED_MAX_FILES"] = "EXCEEDED_MAX_FILES";
    UploadErrorCode["UNSUPPORTED_SOURCE_TYPE"] = "UNSUPPORTED_SOURCE_TYPE";
})(exports.UploadErrorCode || (exports.UploadErrorCode = {}));
/**
 * Updates error codes
 */
exports.UpdatesErrorCode = void 0;
(function (UpdatesErrorCode) {
    UpdatesErrorCode["NEED_RESTART"] = "NEED_RESTART";
    UpdatesErrorCode["POLLING_REQUEST_FAILED"] = "POLLING_REQUEST_FAILED";
})(exports.UpdatesErrorCode || (exports.UpdatesErrorCode = {}));
/**
 * Collect error codes
 */
exports.CollectErrorCode = void 0;
(function (CollectErrorCode) {
    CollectErrorCode["EXECUTE_ERROR"] = "EXECUTE_ERROR";
})(exports.CollectErrorCode || (exports.CollectErrorCode = {}));
/**
 * Snippets error codes
 */
exports.ResourceErrorCode = void 0;
(function (ResourceErrorCode) {
    ResourceErrorCode["INVALID_URL"] = "INVALID_URL";
    ResourceErrorCode["INVALID_RESOURCE"] = "INVALID_RESOURCE";
    ResourceErrorCode["RESOURCE_NOT_FOUND"] = "RESOURCE_NOT_FOUND";
})(exports.ResourceErrorCode || (exports.ResourceErrorCode = {}));
/**
 * Snippets error codes
 */
exports.SharedErrorCode = void 0;
(function (SharedErrorCode) {
    SharedErrorCode["MISSING_CAPTCHA_HANDLER"] = "MISSING_CAPTCHA_HANDLER";
    SharedErrorCode["MISSING_TWO_FACTOR_HANDLER"] = "MISSING_TWO_FACTOR_HANDLER";
})(exports.SharedErrorCode || (exports.SharedErrorCode = {}));
/**
 * Symbol of data definition for serialization
 */
const kSerializeData = Symbol('serializeData');

var params = /*#__PURE__*/Object.freeze({
	__proto__: null
});

var objects = /*#__PURE__*/Object.freeze({
	__proto__: null
});

var responses = /*#__PURE__*/Object.freeze({
	__proto__: null
});

class APIWorker {
    /**
     * Constructor
     */
    constructor(api) {
        this.busy = false;
        this.paused = false;
        this.queue = [];
        this.api = api;
        this.intervalPerRequests = Math.ceil(MINIMUM_TIME_INTERVAL_API / this.api.options.apiLimit);
    }
    enqueue(request) {
        this.queue.push(request);
        this.immediateHeat();
    }
    requeue(request) {
        this.queue.unshift(request);
        this.immediateHeat();
    }
    pause() {
        this.paused = true;
    }
    resume() {
        this.paused = false;
        this.immediateHeat();
    }
    heat() {
        if (this.paused || this.busy || this.queue.length === 0) {
            return;
        }
        this.busy = true;
        if (this.api.options.apiRequestMode === 'sequential') {
            this.execute();
            setTimeout(() => {
                this.busy = false;
                this.immediateHeat();
            }, this.intervalPerRequests);
            return;
        }
        // Burst mode
        const limit = Math.min(this.api.options.apiLimit, this.queue.length);
        for (let i = 0; i < limit && this.queue.length !== 0; i += 1) {
            this.execute();
        }
        const interval = Math.ceil(MINIMUM_TIME_INTERVAL_API - (limit * this.intervalPerRequests));
        setTimeout(() => {
            this.busy = false;
            this.immediateHeat();
        }, interval <= 0
            ? MINIMUM_TIME_INTERVAL_API
            : interval);
    }
    immediateHeat() {
        // Wait next end loop, saves one request or more
        setImmediate(() => this.heat());
    }
}

/**
 * Returns params for execute
 */
const getExecuteParams = (params) => (JSON.stringify(params, (key, value) => (typeof value === 'object' && value !== params
    ? String(value)
    : value)));
/**
 * Returns method for execute
 */
const getExecuteMethod = (method, params = {}) => (`API.${method}(${getExecuteParams(params)})`);
/**
 * Returns chain for execute
 */
const getChainReturn = (methods) => (`return [${methods.join(',')}];`);
/**
 * Resolve task
 */
const resolveExecuteTask = (tasks, result) => {
    let errors = 0;
    result.response.forEach((response, i) => {
        if (response !== false) {
            tasks[i].resolve(response);
            return;
        }
        tasks[i].reject(result.errors[errors]);
        errors += 1;
    });
};
/**
 * Returns random ID
 */
const getRandomId = () => (Math.floor(Math.random() * 10000) * Date.now());
/**
 * Delay N-ms
 */
const delay = (delayed) => (new Promise((resolve) => {
    setTimeout(resolve, delayed);
}));
const lt = /&lt;/g;
const qt = /&gt;/g;
const br = /<br>/g;
const amp = /&amp;/g;
const quot = /&quot;/g;
/**
 * Decodes HTML entities
 */
const unescapeHTML = (text) => (text
    .replace(lt, '<')
    .replace(qt, '>')
    .replace(br, '\n')
    .replace(amp, '&')
    .replace(quot, '"'));
/**
 * Copies object params to new object
 */
const pickProperties = (params, properties) => {
    const copies = {};
    for (const property of properties) {
        copies[property] = params[property];
    }
    return copies;
};
/**
 * Returns peer id type
 */
const getPeerType = (id) => {
    if (PEER_CHAT_ID_OFFSET < id) {
        return exports.MessageSource.CHAT;
    }
    if (id < 0) {
        return exports.MessageSource.GROUP;
    }
    return exports.MessageSource.USER;
};
// eslint-disable-next-line max-len
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
const applyMixins = (derivedCtor, baseCtors) => {
    for (const baseCtor of baseCtors) {
        for (const name of Object.getOwnPropertyNames(baseCtor.prototype)) {
            if (name === 'constructor') {
                continue;
            }
            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
        }
    }
};

const debug$4 = createDebug('vk-io:api');
class SequentialWorker extends APIWorker {
    async execute(request = this.queue.shift()) {
        var _a, _b, _c;
        if (!request) {
            return;
        }
        const { method } = request;
        debug$4(`${method} -->`);
        let response;
        try {
            response = await request.make();
        }
        catch (error) {
            const { options } = this.api;
            if (request.retries === options.apiRetryLimit) {
                debug$4(`${method} <X-`);
                (_a = request.captchaValidate) === null || _a === void 0 ? void 0 : _a.reject(error);
                request.reject(error);
                return;
            }
            request.retries += 1;
            await delay(options.apiWait);
            debug$4(`Request ${method} restarted ${request.retries} times`);
            this.requeue(request);
            return;
        }
        debug$4(`${method} <--`);
        if (response.error !== undefined) {
            this.handleError(request, new APIError(response.error));
            return;
        }
        (_b = request.captchaValidate) === null || _b === void 0 ? void 0 : _b.resolve();
        if (method.startsWith('execute')) {
            request.resolve({
                response: response.response,
                errors: (response.execute_errors || []).map((error) => (new ExecuteError(error)))
            });
            return;
        }
        request.resolve((_c = response.response) !== null && _c !== void 0 ? _c : response);
    }
    /**
     * Error API handler
     */
    async handleError(request, error) {
        var _a;
        const { code } = error;
        if (code === exports.APIErrorCode.TOO_MANY) {
            if (this.paused) {
                this.requeue(request);
                return;
            }
            this.pause();
            await delay(MINIMUM_TIME_INTERVAL_API);
            this.requeue(request);
            this.resume();
            return;
        }
        (_a = request.captchaValidate) === null || _a === void 0 ? void 0 : _a.reject(error);
        if (code !== exports.APIErrorCode.CAPTCHA
            || !this.api.options.callbackService
            || !this.api.options.callbackService.hasCaptchaHandler) {
            request.reject(error);
            return;
        }
        try {
            const { captchaSid } = error;
            const { key, validate } = await this.api.options.callbackService.processingCaptcha({
                type: exports.CaptchaType.API,
                src: error.captchaImg,
                sid: captchaSid,
                request
            });
            request.captchaValidate = validate;
            request.params.captcha_sid = captchaSid;
            request.params.captcha_key = key;
            this.requeue(request);
        }
        catch (e) {
            request.reject(e);
        }
    }
}

/**
 * NOTICE: This file is needed to bridge between CJS and ESM
 *
 * @see https://github.com/node-fetch/node-fetch/issues/1266#issuecomment-913216211
 */
const fetchPromise = import('node-fetch').then(mod => mod.default);
const fetch = (url, init) => (Promise.resolve(fetchPromise).then(fn => fn(url, init)));

class APIRequest {
    /**
     * Constructor
     */
    constructor({ api, method, params = {} }) {
        this.retries = 0;
        this.api = api;
        this.method = method;
        this.params = { ...params };
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Returns string to execute
     */
    toString() {
        return getExecuteMethod(this.method, this.params);
    }
    /**
     * Sends a request to the server
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async make() {
        const { options } = this.api;
        const params = {
            access_token: options.token,
            v: options.apiVersion,
            ...this.params
        };
        if (options.language !== undefined) {
            params.lang = options.language;
        }
        const controller = new abortController.AbortController();
        const timeout = setTimeout(() => controller.abort(), options.apiTimeout);
        try {
            const response = await fetch(`${options.apiBaseUrl}/${this.method}`, {
                method: 'POST',
                compress: false,
                agent: options.agent,
                signal: controller.signal,
                headers: {
                    ...options.apiHeaders,
                    connection: 'keep-alive'
                },
                body: new URLSearchParams(Object.entries(params)
                    .filter(({ 1: value }) => value !== undefined))
            });
            const result = await response.json();
            return result;
        }
        finally {
            clearTimeout(timeout);
        }
    }
}
inspectable.inspectable(APIRequest, {
    serialize: ({ method, params }) => ({
        method,
        params
    })
});

class ParallelWorker extends SequentialWorker {
    async execute() {
        const { queue } = this;
        if (this.skipMethod(queue[0].method)) {
            super.execute();
            return;
        }
        const { apiExecuteCount } = this.api.options;
        const tasks = [];
        for (let i = 0; i < this.queue.length; i += 1) {
            if (this.skipMethod(queue[i].method)) {
                continue;
            }
            tasks.push(queue.splice(i, 1)[0]);
            i -= 1;
            if (tasks.length >= apiExecuteCount) {
                break;
            }
        }
        if (tasks.length === 0) {
            return;
        }
        const request = new APIRequest({
            api: this.api,
            method: 'execute',
            params: {
                code: getChainReturn(tasks.map(String))
            }
        });
        super.execute(request);
        try {
            resolveExecuteTask(tasks, await request.promise);
        }
        catch (error) {
            for (const task of tasks) {
                task.reject(error);
            }
        }
    }
    // eslint-disable-next-line class-methods-use-this
    skipMethod(method) {
        return method.startsWith('execute')
            || this.api.options.apiExecuteUnsupportedMethods.includes(method);
    }
}

class ParallelSelectedWorker extends ParallelWorker {
    skipMethod(method) {
        return super.skipMethod(method)
            || !this.api.options.apiExecuteMethods.includes(method);
    }
}

var version = "4.8.2";

const groupMethods = [
    'account',
    'ads',
    'appWidgets',
    'apps',
    'audio',
    'auth',
    'board',
    'database',
    'docs',
    'fave',
    'friends',
    'gifts',
    'groups',
    'leads',
    'leadForms',
    'likes',
    'market',
    'messages',
    'newsfeed',
    'notes',
    'notifications',
    'orders',
    'pages',
    'photos',
    'places',
    'polls',
    'podcasts',
    'prettyCards',
    'store',
    'search',
    'secure',
    'stats',
    'status',
    'storage',
    'stories',
    'streaming',
    'users',
    'utils',
    'video',
    'wall',
    'widgets',
    'junction',
    'articles',
    'donut',
    'specials',
    'statEvents',
    'loyaltyTeen',
    'marusia'
];
const workers = {
    sequential: SequentialWorker,
    parallel: ParallelWorker,
    parallel_selected: ParallelSelectedWorker
};
/**
 * Working with API methods
 */
class API {
    /**
     * Constructor
     */
    constructor(options) {
        this.options = {
            agent: https.globalAgent,
            language: undefined,
            apiMode: 'sequential',
            apiRequestMode: 'sequential',
            apiWait: 3e3,
            apiLimit: 3,
            apiVersion: '5.131',
            apiBaseUrl: 'https://api.vk.com/method',
            apiRetryLimit: 3,
            apiTimeout: 10e3,
            apiHeaders: {
                // eslint-disable-next-line @typescript-eslint/naming-convention
                'User-Agent': `vk-io/${version} (+https://github.com/negezor/vk-io)`
            },
            apiExecuteCount: 25,
            apiExecuteMethods: ['messages.send'],
            apiExecuteUnsupportedMethods: [
                'photos.save',
                'photos.saveWallPhoto',
                'photos.saveOwnerPhoto',
                'photos.saveMessagesPhoto',
                'messages.setChatPhoto',
                'photos.saveMarketPhoto',
                'photos.saveMarketAlbumPhoto',
                'audio.save',
                'docs.save',
                'photos.saveOwnerCoverPhoto',
                'stories.save',
                'polls.savePhoto'
            ],
            ...options
        };
        for (const group of groupMethods) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this[group] = new Proxy(Object.create(null), {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                get: (obj, prop) => (params) => (this.callWithRequest(new APIRequest({
                    api: this,
                    method: `${group}.${prop}`,
                    params
                })))
            });
        }
        this.worker = this.getWorker();
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Call execute method
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    execute(params) {
        return this.call('execute', params);
    }
    /**
     * Call execute procedure
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    procedure(name, params) {
        return this.call(`execute.${name}`, params);
    }
    /**
     * Call raw method
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    call(method, params) {
        return this.callWithRequest(new APIRequest({
            method,
            params,
            api: this
        }));
    }
    /**
     * Adds request for queue
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callWithRequest(request) {
        this.worker.enqueue(request);
        return request.promise;
    }
    getWorker() {
        const Worker = workers[this.options.apiMode];
        if (!Worker) {
            throw new VKError({
                message: 'Unsupported api mode',
                code: 'UNSUPPORTED_MODE'
            });
        }
        return new Worker(this);
    }
    updateWorker() {
        const newWorker = this.getWorker();
        if (this.worker.constructor === newWorker.constructor) {
            return;
        }
        if (this.worker.busy) {
            this.worker.pause();
            newWorker.pause();
            // @ts-expect-error
            newWorker.queue = [...this.worker.queue];
            setTimeout(() => newWorker.resume(), MINIMUM_TIME_INTERVAL_API);
        }
        this.worker = newWorker;
    }
}
inspectable.inspectable(API, {
    serialize: ({ options }) => ({
        options: {
            token: options.token
                ? '[set]'
                : '[none]'
        }
    })
});

/**
 * Check object is stream
 */
const isStream = (source) => (typeof source === 'object' && source instanceof stream.Stream);
/**
 * Copies object params to new object
 */
const pickExistingProperties = (params, properties) => {
    const copies = {};
    for (const property of properties) {
        if (params[property] !== undefined) {
            copies[property] = params[property];
        }
    }
    return copies;
};
const normalizeSource = (rawSource) => {
    if ('value' in rawSource) {
        return {
            values: [rawSource]
        };
    }
    return {
        ...rawSource,
        values: Array.isArray(rawSource.values)
            ? rawSource.values
            : [rawSource.values]
    };
};
const streamToBuffer = async (rawStream) => {
    const stream$1 = new stream.PassThrough();
    rawStream.pipe(stream$1);
    const chunks = [];
    let totalSize = 0;
    for await (const chunk of stream$1) {
        totalSize += chunk.length;
        chunks.push(chunk);
    }
    return Buffer.concat(chunks, totalSize);
};

/**
 * Parse attachments
 */
const parseAttachmentRe = /^([a-z_]+)(-?\d+)_(\d+)_?(\w+)?$/;
class Attachment {
    /**
     * Constructor
     */
    constructor(options) {
        this.api = options.api;
        this.type = options.type;
        // @ts-expect-error
        this.payload = options.payload;
        this.$filled = false;
    }
    get id() {
        return this.payload.id;
    }
    get ownerId() {
        return this.payload.owner_id;
    }
    get accessKey() {
        return this.payload.access_key;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Parse attachment with string
     */
    static fromString(attachment, api) {
        if (!parseAttachmentRe.test(attachment)) {
            throw new TypeError('Incorrect attachment');
        }
        const [, type, ownerId, id, accessKey] = attachment.match(parseAttachmentRe);
        return new Attachment({
            api,
            type,
            payload: {
                id: Number(id),
                owner_id: Number(ownerId),
                access_key: accessKey
            }
        });
    }
    /**
     * Returns whether the attachment is filled
     */
    get isFilled() {
        return this.$filled;
    }
    /**
     * Can be attached via string representation
     */
    // eslint-disable-next-line class-methods-use-this
    get canBeAttached() {
        return true;
    }
    /**
     * Checks that the attachment is equivalent with object
     */
    equals(attachment) {
        const target = typeof attachment === 'string'
            ? Attachment.fromString(attachment, this.api)
            : attachment;
        return (this.type === target.type
            && this.ownerId === target.ownerId
            && this.id === target.id);
    }
    /**
     * Returns a string to attach a VK
     */
    toString() {
        const accessKey = this.accessKey !== undefined
            ? `_${this.accessKey}`
            : '';
        return `${this.type}${this.ownerId}_${this.id}${accessKey}`;
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return {
            id: this.id,
            ownerId: this.ownerId,
            accessKey: this.accessKey,
            ...this[kSerializeData]()
        };
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return {
            payload: this.payload
        };
    }
}
inspectable.inspectable(Attachment, {
    serialize: (instance) => instance.toJSON(),
    stringify: (instance, payload, context) => (`${context.stylize(instance.constructor.name, 'special')} <${context.stylize(String(instance), 'string')}> ${context.inspect(payload)}`)
});

class ExternalAttachment {
    /**
     * Constructor
     */
    constructor(options) {
        this.api = options.api;
        this.type = options.type;
        this.payload = options.payload;
        this.$filled = false;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Returns whether the attachment is filled
     */
    get isFilled() {
        return this.$filled;
    }
    /**
     * Can be attached via string representation
     */
    // eslint-disable-next-line class-methods-use-this
    get canBeAttached() {
        return false;
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return this[kSerializeData]();
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return {
            payload: this.payload
        };
    }
}
inspectable.inspectable(ExternalAttachment, {
    serialize: instance => instance.toJSON(),
    stringify: (instance, payload, context) => (`${context.stylize(instance.constructor.name, 'special')} ${context.inspect(payload)}`)
});

const SMALL_SIZES = ['m', 's'];
const MEDIUM_SIZES = ['y', 'r', 'q', 'p', ...SMALL_SIZES];
const LARGE_SIZES = ['w', 'z', ...MEDIUM_SIZES];
class PhotoAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.PHOTO
        });
        this.$filled = this.payload.album_id !== undefined && this.payload.date !== undefined;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const [photo] = await this.api.photos.getById({
            photos: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        this.payload = photo;
        this.$filled = true;
    }
    /**
     * Returns the ID of the user who uploaded the image
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the ID of the album
     */
    get albumId() {
        return this.payload.album_id;
    }
    /**
     * Returns the photo text
     */
    get text() {
        return this.payload.text;
    }
    /**
     * Returns the date when this photo was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the photo height
     */
    get height() {
        return this.payload.height;
    }
    /**
     * Returns the photo width
     */
    get width() {
        return this.payload.width;
    }
    /**
     * Returns the URL of a small photo
     * (130 or 75)
     */
    get smallSizeUrl() {
        if (!this.$filled) {
            return undefined;
        }
        const [size] = this.getSizes(SMALL_SIZES);
        return size.url;
    }
    /**
     * Returns the URL of a medium photo
     * (807 or 604 or less)
     */
    get mediumSizeUrl() {
        if (!this.$filled) {
            return undefined;
        }
        const [size] = this.getSizes(MEDIUM_SIZES);
        return size.url;
    }
    /**
     * Returns the URL of a large photo
     * (2560 or 1280 or less)
     */
    get largeSizeUrl() {
        if (!this.$filled) {
            return undefined;
        }
        const [size] = this.getSizes(LARGE_SIZES);
        return size.url;
    }
    /**
     * Returns the sizes
     */
    get sizes() {
        return this.payload.sizes;
    }
    /**
     * Returns the sizes of the required types
     */
    getSizes(sizeTypes) {
        const { sizes } = this;
        if (!sizes) {
            return [];
        }
        return sizeTypes
            .map((sizeType) => (sizes.find((size) => size.type === sizeType)))
            .filter(Boolean);
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'userId',
            'albumId',
            'text',
            'createdAt',
            'height',
            'width',
            'smallSizeUrl',
            'mediumSizeUrl',
            'largeSizeUrl',
            'sizes'
        ]);
    }
}

class PollAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.POLL
        });
        this.$filled = this.payload.answers !== undefined;
        if (this.payload.photo) {
            this.photo = new PhotoAttachment({
                api: this.api,
                payload: this.payload.photo
            });
        }
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const poll = await this.api.polls.getById({
            poll_id: this.id,
            owner_id: this.ownerId
        });
        this.payload = poll;
        this.$filled = true;
    }
    /**
     * Checks whether the poll is anonymous
     */
    get isAnonymous() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.anonymous);
    }
    /**
     * Checks whether the poll allows multiple choice of answers
     */
    get isMultiple() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.multiple);
    }
    /**
     * Checks whether the poll is complete
     */
    get isClosed() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.closed);
    }
    /**
     * Check whether questions are attached to the discussion
     */
    get isBoard() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.is_board);
    }
    /**
     * Check if you can edit the poll
     */
    get isCanEdit() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.can_edit);
    }
    /**
     * Check if you can vote in the survey
     */
    get isCanVote() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.can_vote);
    }
    /**
     * Check if you can complain about the poll
     */
    get isCanReport() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.can_report);
    }
    /**
     * Check if you can share a survey
     */
    get isCanShare() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.can_share);
    }
    /**
     * Returns the ID of the poll author
     */
    get authorId() {
        return this.payload.author_id;
    }
    /**
     * Returns the question text
     */
    get question() {
        return this.payload.question;
    }
    /**
     * Returns the date when this poll was created
     */
    get createdAt() {
        return this.payload.created;
    }
    /**
     * Returns the end date of the poll in Unixtime. 0, if the poll is unlimited
     */
    get endedAt() {
        return this.payload.end_date;
    }
    /**
     * Returns the number of votes
     */
    get votes() {
        return this.payload.votes;
    }
    /**
     * Returns the identifiers of the response options selected by the current user
     */
    get answerIds() {
        return this.payload.answer_ids;
    }
    /**
     * Returns the identifiers of 3 friends who voted in the poll
     */
    get friends() {
        if (!this.$filled) {
            return undefined;
        }
        return this.payload.friends || [];
    }
    /**
     * Returns the information about the options for the answer
     */
    get answers() {
        return this.payload.answers;
    }
    /**
     * Returns the poll snippet background
     */
    get background() {
        return this.payload.background;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'authorId',
            'question',
            'createdAt',
            'endedAt',
            'votes',
            'answerIds',
            'friends',
            'answers',
            'background',
            'photo'
        ]);
    }
}

class GiftAttachment extends ExternalAttachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.GIFT
        });
    }
    /**
     * Returns the identifier gift
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return {
            id: this.id
        };
    }
}

class Attachmentable {
    /**
     * Checks for the presence of attachments
     */
    hasAttachments(type) {
        if (type === undefined) {
            return this.attachments.length > 0;
        }
        return this.attachments.some(attachment => (attachment.type === type));
    }
    getAttachments(type) {
        if (type === undefined) {
            return this.attachments;
        }
        return this.attachments.filter(attachment => (attachment.type === type));
    }
}

const getForwards = (rootForwards) => {
    const forwards = [];
    for (const forward of rootForwards) {
        forwards.push(forward, ...getForwards(forward.forwards));
    }
    return forwards;
};
const kFlatten = Symbol('flatten');
class MessageForwardsCollection extends Array {
    /**
     * Returns a flat copy of forwards
     */
    get flatten() {
        if (!this[kFlatten]) {
            this[kFlatten] = getForwards(this);
        }
        return this[kFlatten];
    }
}
applyMixins(MessageForwardsCollection, [
    class CustomAttachmentable {
        hasAttachments(type) {
            return this.flatten.some(forward => (forward.hasAttachments(type)));
        }
        getAttachments(type) {
            const attachments = this.flatten.map(forward => (
            // @ts-expect-error
            forward.getAttachments(type)));
            return [].concat(...attachments);
        }
    }
]);

const attachmentsTypes = {
    [exports.AttachmentType.ALBUM]: undefined,
    [exports.AttachmentType.STORY]: undefined,
    [exports.AttachmentType.PODCAST]: undefined,
    [exports.AttachmentType.TEXTLIVE]: undefined,
    [exports.AttachmentType.POLL]: () => PollAttachment,
    [exports.AttachmentType.GIFT]: () => GiftAttachment,
    [exports.AttachmentType.WALL]: () => WallAttachment,
    [exports.AttachmentType.LINK]: () => LinkAttachment,
    [exports.AttachmentType.PHOTO]: () => PhotoAttachment,
    [exports.AttachmentType.AUDIO]: () => AudioAttachment,
    [exports.AttachmentType.STORY]: () => StoryAttachment,
    [exports.AttachmentType.VIDEO]: () => VideoAttachment,
    [exports.AttachmentType.DOCUMENT]: () => DocumentAttachment,
    [exports.AttachmentType.MARKET]: () => MarketAttachment,
    [exports.AttachmentType.STICKER]: () => StickerAttachment,
    [exports.AttachmentType.GRAFFITI]: () => GraffitiAttachment,
    [exports.AttachmentType.WALL_REPLY]: () => WallReplyAttachment,
    [exports.AttachmentType.MARKET_ALBUM]: () => MarketAlbumAttachment,
    [exports.AttachmentType.AUDIO_MESSAGE]: () => AudioMessageAttachment
};
/**
 * Transform raw attachments to wrapper
 */
const transformAttachments = (
// eslint-disable-next-line @typescript-eslint/no-explicit-any
rawAttachments, api
// eslint-disable-next-line function-paren-newline
) => {
    const attachments = [];
    for (const rawAttachment of rawAttachments) {
        const type = rawAttachment.type;
        const attachmentFactory = attachmentsTypes[type];
        if (attachmentFactory === undefined) {
            continue;
        }
        const AttachmentConstructor = attachmentFactory();
        attachments.push(new AttachmentConstructor({
            api,
            payload: rawAttachment[type]
        }));
    }
    return attachments;
};

const kAttachments$1 = Symbol('attachments');
const kCopyHistoryAttachments = Symbol('copyHistoryAttachments');
class WallAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.WALL
        });
        this.$filled = this.payload.date !== undefined;
        this.applyPayload(options.payload);
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const [post] = await this.api.wall.getById({
            posts: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        this.applyPayload(post);
        this.$filled = true;
    }
    /**
     * Checks has comments
     */
    get hasComments() {
        const { commentsCount } = this;
        return commentsCount !== undefined
            ? commentsCount > 0
            : undefined;
    }
    /**
     * Checks has ads in post
     */
    get hasAds() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.marked_as_ads);
    }
    /**
     * Checks has this user reposted
     */
    get hasUserReposted() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.reposts.user_reposted);
    }
    /**
     * Checks has this user likes
     */
    get hasUserLike() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.likes.user_likes);
    }
    /**
     * Checks can the current user comment on the entry
     */
    get isCanUserCommented() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.comments.can_post);
    }
    /**
     * Checks if a community can comment on a post
     */
    get isCanGroupsCommented() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.comments.groups_can_post);
    }
    /**
     * Checks if you can comment on a post
     */
    get isCanCommented() {
        return this.isCanUserCommented || this.isCanGroupsCommented;
    }
    /**
     * Checks if a user can close on a comments
     */
    get isCanCloseComments() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.comments.can_close);
    }
    /**
     * Checks if a user can open on a comments
     */
    get isCanOpenComments() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.comments.can_open);
    }
    /**
     * Checks whether the current user can like the record
     */
    get isCanLike() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.likes.can_like);
    }
    /**
     * hecks whether the current user can repost the record
     */
    get isCanReposted() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.likes.can_publish);
    }
    /**
     * Checks is can this user pin post
     */
    get isCanPin() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.can_pin);
    }
    /**
     * Checks is can this user delete post
     */
    get isCanDelete() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.can_delete);
    }
    /**
     * Checks is can this user edit post
     */
    get isCanEdit() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.can_edit);
    }
    /**
     * Checks is can this user edit post
     */
    get isPinned() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.is_pinned);
    }
    /**
     * Checks is post created only by friends
     */
    get isFriendsOnly() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.friends_only);
    }
    /**
     * Checks is bookmarked current user
     */
    get isFavorited() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.is_favorite);
    }
    get ownerId() {
        return this.payload.owner_id || this.payload.to_id;
    }
    /**
     * Returns the identifier author
     */
    get authorId() {
        return this.payload.from_id;
    }
    /**
     * Returns the administrator identifier that posted the entry
     */
    get createdUserId() {
        return this.payload.created_by;
    }
    /**
     * The identifier of the record owner, in response to which the current
     */
    get replyOwnerId() {
        return this.payload.reply_owner_id;
    }
    /**
     * The identifier of the record in response to which the current one was left.
     */
    get replyPostId() {
        return this.payload.reply_post_id;
    }
    /**
     * Returns author identifier if the entry was published
     * on behalf of the community and signed by the user
     */
    get signerId() {
        return this.payload.signer_id;
    }
    /**
     * Returns the id of the pending entry. This field is returned when the entry was on the timer.
     */
    get postponedId() {
        return this.payload.postponed_id;
    }
    /**
     * Returns the date when this post was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the post type
     */
    get postType() {
        return this.payload.post_type;
    }
    /**
     * Returns the post text
     */
    get text() {
        return this.payload.text;
    }
    /**
     * Returns the number of record views
     */
    get viewsCount() {
        var _a;
        return (_a = this.payload.views) === null || _a === void 0 ? void 0 : _a.count;
    }
    /**
     * Returns the likes count
     */
    get likesCount() {
        var _a;
        return (_a = this.payload.likes) === null || _a === void 0 ? void 0 : _a.count;
    }
    /**
     * Returns the reposts count
     */
    get repostsCount() {
        var _a;
        return (_a = this.payload.reposts) === null || _a === void 0 ? void 0 : _a.count;
    }
    /**
     * Returns the comments count
     */
    get commentsCount() {
        var _a;
        return (_a = this.payload.comments) === null || _a === void 0 ? void 0 : _a.count;
    }
    /**
     * Returns the likes info
     */
    get likes() {
        return this.payload.likes;
    }
    /**
     * Returns the post source
     */
    get postSource() {
        return this.payload.post_source;
    }
    /**
     * Returns the geolocation
     */
    get geo() {
        return this.payload.geo;
    }
    /**
     * Returns the copyright
     */
    get copyright() {
        return this.payload.copyright;
    }
    /**
     * Returns the attachments
     */
    get attachments() {
        return this[kAttachments$1];
    }
    /**
     * Returns the history of reposts for post
     */
    get copyHistory() {
        return this[kCopyHistoryAttachments];
    }
    /**
     * Applies the payload
     */
    applyPayload(payload) {
        this.payload = payload;
        this[kAttachments$1] = transformAttachments(payload.attachments || [], this.api);
        this[kCopyHistoryAttachments] = (payload.copy_history || []).map((history) => (new WallAttachment({
            api: this.api,
            payload: history
        })));
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'authorId',
            'createdUserId',
            'replyOwnerId',
            'replyPostId',
            'signerId',
            'postponedId',
            'createdAt',
            'postType',
            'text',
            'viewsCount',
            'likesCount',
            'repostsCount',
            'commentsCount',
            'likes',
            'postSource',
            'geo',
            'copyright',
            'copyHistory',
            'attachments'
        ]);
    }
}
applyMixins(WallAttachment, [Attachmentable]);

const kPhoto$1 = Symbol('kPhoto');
class LinkAttachment extends ExternalAttachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.LINK
        });
        if (this.payload.photo) {
            this[kPhoto$1] = new PhotoAttachment({
                api: this.api,
                payload: this.payload.photo
            });
        }
    }
    /**
     * Checks for the presence of a photo in a link
     */
    get hasPhoto() {
        return Boolean(this[kPhoto$1]);
    }
    /**
     * Returns the title
     */
    get title() {
        return this.payload.title;
    }
    /**
     * Returns the title
     */
    get caption() {
        return this.payload.caption;
    }
    /**
     * Returns the description
     */
    get description() {
        return this.payload.description;
    }
    /**
     * Returns the URL of the link
     */
    get url() {
        return this.payload.url;
    }
    /**
     * Returns the product
     */
    get product() {
        return this.payload.product;
    }
    /**
     * Returns the button
     */
    get button() {
        return this.payload.button;
    }
    /**
     * Returns the photo
     */
    get photo() {
        return this[kPhoto$1];
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'title',
            'caption',
            'description',
            'url',
            'product',
            'button',
            'photo'
        ]);
    }
}

class AudioAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.AUDIO
        });
        this.$filled = this.payload.duration !== undefined && this.payload.date !== undefined;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-expect-error
        const { items: [audio] } = await this.api.audio.getById({
            audios: `${this.ownerId}_${this.id}`
        });
        this.payload = audio;
        this.$filled = true;
    }
    /**
     * Checks whether audio is in high quality
     */
    get isHq() {
        const { is_hq: isHq } = this.payload;
        if (isHq === undefined) {
            return undefined;
        }
        return isHq === 1;
    }
    /**
     * Returns the ID of the lyric
     */
    get lyricsId() {
        return this.payload.lyrics_id;
    }
    /**
     * Returns the ID of the album
     */
    get albumId() {
        return this.payload.album_id;
    }
    /**
     * Returns the ID of the genre
     */
    get genreId() {
        return this.payload.genre_id;
    }
    /**
     * Returns the title
     */
    get title() {
        return this.payload.title;
    }
    /**
     * Returns the artist
     */
    get artist() {
        return this.payload.artist;
    }
    /**
     * Returns the duration
     */
    get duration() {
        return this.payload.duration;
    }
    /**
     * Returns the date object when this audio was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the URL of the audio
     */
    get url() {
        return this.payload.url;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'lyricsId',
            'albumId',
            'genreId',
            'title',
            'artist',
            'duration',
            'createdAt',
            'url'
        ]);
    }
}

class VideoAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.VIDEO
        });
        this.$filled = this.payload.date !== undefined;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const { items } = await this.api.video.get({
            videos: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        const [video] = items;
        this.payload = video;
        this.$filled = true;
    }
    /**
     * Checks whether the video is repeatable
     */
    get isRepeat() {
        return this.checkBooleanInProperty('repeat');
    }
    /**
     * Checks that the user can add a video to himself
     */
    get isCanAdd() {
        return this.checkBooleanInProperty('can_add');
    }
    /**
     * Checks if the user can edit the video
     */
    get isCanEdit() {
        return this.checkBooleanInProperty('can_edit');
    }
    /**
     * Checks whether the video is being processed
     */
    get isProcessing() {
        return this.checkBooleanInProperty('processing');
    }
    /**
     * Checks whether the video is a broadcast
     */
    get isBroadcast() {
        return this.checkBooleanInProperty('live');
    }
    /**
     * Checks whether the video is a broadcast
     */
    get isUpcoming() {
        return this.checkBooleanInProperty('upcoming');
    }
    /**
     * Checks is bookmarked current user
     */
    get isFavorited() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.is_favorite);
    }
    /**
     * Returns the title
     */
    get title() {
        return this.payload.title;
    }
    /**
     * Returns the description
     */
    get description() {
        return this.payload.description;
    }
    /**
     * Returns the duration
     */
    get duration() {
        return this.payload.duration;
    }
    /**
     * Returns the date when this video was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the date when this video was added
     */
    get addedAt() {
        return this.payload.adding_date;
    }
    /**
     * Returns the count views
     */
    get viewsCount() {
        return this.payload.views;
    }
    /**
     * Returns the count comments
     */
    get commentsCount() {
        return this.payload.comments;
    }
    /**
     * Returns the URL of the page with the player
     */
    get player() {
        return this.payload.player;
    }
    /**
     * Returns the name of the platform (for video recordings added from external sites)
     */
    get platformName() {
        return this.payload.platform;
    }
    /**
     * Checks for a boolean value in the property
     */
    checkBooleanInProperty(name) {
        const property = this.payload[name];
        if (typeof property !== 'number') {
            return undefined;
        }
        return property === 1;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'title',
            'description',
            'duration',
            'createdAt',
            'addedAt',
            'viewsCount',
            'commentsCount',
            'player',
            'platformName'
        ]);
    }
}

const kVideo = Symbol('video');
const kPhoto = Symbol('photo');
const kParentStory = Symbol('parentStory');
class StoryAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.STORY
        });
        this.applyPayload(options.payload);
        this.$filled = this.payload.is_deleted !== undefined || this.payload.is_expired !== undefined;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const { items: [story] } = await this.api.stories.getById({
            stories: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        this.applyPayload(story);
        this.$filled = true;
    }
    /**
     * Checks is story expired
     */
    get isExpired() {
        return this.payload.is_expired;
    }
    /**
     * Checks is story deleted
     */
    get isDeleted() {
        return this.payload.is_deleted;
    }
    /**
     * Checks is story viewed by current user
     */
    get isSeen() {
        if (!this.$filled) {
            return undefined;
        }
        return this.payload.seen === 1;
    }
    /**
     * Checks can story reply
     */
    get isCanReply() {
        if (!this.$filled) {
            return undefined;
        }
        return this.payload.can_reply === 1;
    }
    /**
     * Checks can story share
     */
    get isCanShare() {
        if (!this.$filled) {
            return undefined;
        }
        return this.payload.can_share === 1;
    }
    /**
     * Checks can story comment
     */
    get isCanComment() {
        if (!this.$filled) {
            return undefined;
        }
        return this.payload.can_comment === 1;
    }
    /**
     * Returns the type of story
     */
    get storyType() {
        return this.payload.type;
    }
    /**
     * Returns the story photo
     */
    get photo() {
        return this[kPhoto];
    }
    /**
     * Returns the story video
     */
    get video() {
        return this[kVideo];
    }
    /**
     * Returns the date when this story was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the date when this story was expires
     */
    get expiresAt() {
        return this.payload.expires_at;
    }
    /**
     * Returns the story views count
     */
    get viewsCount() {
        return this.payload.views;
    }
    /**
     * Returns the story link
     */
    get link() {
        return this.payload.link;
    }
    /**
     * Returns the story replies
     */
    get replies() {
        return this.payload.replies;
    }
    /**
     * Returns the parent story id
     */
    get parentStoryId() {
        return this.payload.parent_story_id;
    }
    /**
     * Returns the parent story owner id
     */
    get parentStoryOwnerId() {
        return this.payload.parent_story_owner_id;
    }
    /**
     * Returns the parent story
     */
    get parentStory() {
        return this[kParentStory];
    }
    /**
     * Returns the parent story clickable stickers
     */
    get clickableStickers() {
        return this.payload.clickable_stickers;
    }
    /**
     * Applies the payload
     */
    applyPayload(payload) {
        this.payload = payload;
        if (payload.photo) {
            this[kPhoto] = new PhotoAttachment({
                api: this.api,
                payload: payload.photo
            });
        }
        if (payload.video) {
            this[kVideo] = new VideoAttachment({
                api: this.api,
                payload: payload.video
            });
        }
        if (payload.parent_story) {
            this[kParentStory] = new StoryAttachment({
                api: this.api,
                payload: payload.parent_story
            });
        }
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        if (this.isDeleted) {
            return pickProperties(this, [
                'isDeleted'
            ]);
        }
        if (this.isExpired) {
            return pickProperties(this, [
                'isExpired',
                'expiresAt'
            ]);
        }
        return pickProperties(this, [
            'isExpired',
            'isDeleted',
            'isSeen',
            'isCanReply',
            'isCanShare',
            'isCanComment',
            'storyType',
            'photo',
            'video',
            'createdAt',
            'expiresAt',
            'viewsCount',
            'link',
            'replies',
            'parentStoryId',
            'parentStoryOwnerId',
            'parentStory',
            'clickableStickers'
        ]);
    }
}

class MarketAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.MARKET
        });
        this.$filled = this.payload.title !== undefined && this.payload.date !== undefined;
        this.applyPayload(options.payload);
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const { items } = await this.api.market.getById({
            item_ids: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        this.$filled = true;
        this.applyPayload(items[0]);
    }
    /**
     * Checks is bookmarked current user
     */
    get isFavorited() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.is_favorite);
    }
    /**
     * Checks is can comment for current user
     */
    get canComment() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.can_comment);
    }
    /**
     * Checks is can repost for current user
     */
    get canRepost() {
        if (!this.$filled) {
            return undefined;
        }
        return Boolean(this.payload.can_repost);
    }
    /**
     * Returns product title
     */
    get title() {
        return this.payload.title;
    }
    /**
     * Returns product description
     */
    get description() {
        return this.payload.description;
    }
    /**
     * Returns product price
     */
    get price() {
        return this.payload.price;
    }
    /**
     * Returns product dimensions
     */
    get dimensions() {
        return this.payload.dimensions;
    }
    /**
     * Returns product dimensions
     */
    get weight() {
        return this.payload.weight;
    }
    /**
     * Returns product category
     */
    get category() {
        return this.payload.category;
    }
    /**
     * Returns product thumbnail url
     */
    get thumbnailUrl() {
        return this.payload.thumb_photo;
    }
    /**
     * Returns the date when this product was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns product availability
     *
     * **0** - the product is available
     *
     * **1** - the item has been deleted
     *
     * **2** - the product is not available
     */
    get availability() {
        return this.payload.availability;
    }
    /**
     * Returns product likes
     */
    get likes() {
        return this.payload.likes;
    }
    /**
     * Returns product url
     */
    get url() {
        return this.payload.url;
    }
    /**
     * Returns product button title
     */
    get buttonTitle() {
        return this.payload.button_title;
    }
    /**
     * Applies the payload
     */
    applyPayload(payload) {
        this.payload = payload;
        if (this.payload.photos) {
            this.photos = this.payload.photos.map(photo => (new PhotoAttachment({
                api: this.api,
                payload: photo
            })));
        }
    }
}

class StickerAttachment extends ExternalAttachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.STICKER
        });
    }
    /**
     * Returns the identifier sticker
     */
    get id() {
        return this.payload.sticker_id;
    }
    /**
     * Returns the identifier product
     */
    get productId() {
        return this.payload.product_id;
    }
    /**
     * Returns the images sizes
     */
    get images() {
        return this.payload.images || [];
    }
    /**
     * Returns the images sizes with backgrounds
     */
    get imagesWithBackground() {
        return this.payload.images_with_background || [];
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'id',
            'productId',
            'images',
            'imagesWithBackground'
        ]);
    }
}

class GraffitiAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.GRAFFITI
        });
        this.$filled = this.payload.url !== undefined;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const [document] = await this.api.docs.getById({
            docs: `${this.ownerId}_${this.id}`
        });
        this.payload = document;
        this.$filled = true;
    }
    /**
     * Returns the graffiti height
     */
    get height() {
        return this.payload.height;
    }
    /**
     * Returns the graffiti width
     */
    get width() {
        return this.payload.width;
    }
    /**
     * Returns the URL of the document
     */
    get url() {
        return this.payload.url;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'height',
            'width',
            'url'
        ]);
    }
}

class DocumentAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.DOCUMENT
        });
        this.$filled = this.payload.ext !== undefined && this.payload.date !== undefined;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const [document] = await this.api.docs.getById({
            docs: `${this.ownerId}_${this.id}`
        });
        this.payload = document;
        this.$filled = true;
    }
    /**
     * Checks if the document is a text
     */
    get isText() {
        if (!this.$filled) {
            return undefined;
        }
        return this.typeId === 1;
    }
    /**
     * Checks if the document is an archive
     */
    get isArchive() {
        if (!this.$filled) {
            return undefined;
        }
        return this.typeId === 2;
    }
    /**
     * Checks if the document is a gif file
     */
    get isGif() {
        if (!this.$filled) {
            return undefined;
        }
        return this.typeId === 3;
    }
    /**
     * Checks if the document is an image
     */
    get isImage() {
        if (!this.$filled) {
            return undefined;
        }
        return this.typeId === 4;
    }
    /**
     * Checks if the document is a graffiti
     */
    get isGraffiti() {
        if (!this.$filled) {
            return undefined;
        }
        return this.hasPreviewProperty('graffiti');
    }
    /**
     * Checks if the document is an audio
     */
    get isAudio() {
        if (!this.$filled) {
            return undefined;
        }
        return this.typeId === 5;
    }
    /**
     * Checks if the document is a voice
     */
    get isVoice() {
        if (!this.$filled) {
            return undefined;
        }
        return this.hasPreviewProperty('audio_message');
    }
    /**
     * Checks if the document is a video
     */
    get isVideo() {
        if (!this.$filled) {
            return undefined;
        }
        return this.typeId === 6;
    }
    /**
     * Checks if the document is a book
     */
    get isBook() {
        if (!this.$filled) {
            return undefined;
        }
        return this.typeId === 7;
    }
    /**
     * Returns the document title
     */
    get title() {
        return this.payload.title;
    }
    /**
     * Returns the date when this document was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the type identifier
     *
     * **1** - text documents
     *
     * **2** - archives
     *
     * **3** - gif
     *
     * **4** - images
     *
     * **5** - audio
     *
     * **6** - video
     *
     * **7** - e-books
     *
     * **8** - unknown
     */
    get typeId() {
        return this.payload.type;
    }
    /**
     * Returns the size in bytes
     */
    get size() {
        return this.payload.size;
    }
    /**
     * Returns the extension
     */
    get extension() {
        return this.payload.ext;
    }
    /**
     * Returns the URL of the document
     */
    get url() {
        return this.payload.url;
    }
    /**
     * Returns the info to preview
     */
    get preview() {
        return this.payload.preview;
    }
    /**
     * Checks for a property in preview
     */
    hasPreviewProperty(name) {
        var _a;
        return ((_a = this.preview) === null || _a === void 0 ? void 0 : _a[name]) !== undefined;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'title',
            'typeId',
            'createdAt',
            'extension',
            'url'
        ]);
    }
}

class WallReplyAttachment extends ExternalAttachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.WALL_REPLY
        });
        this.attachments = transformAttachments(options.payload.attachments || [], this.api);
    }
    /**
     * Returns the comment id
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the comment owner id
     */
    get ownerId() {
        return this.payload.owner_id;
    }
    /**
     * Returns the comment post id
     */
    get postId() {
        return this.payload.owner_id;
    }
    /**
     * Returns the identifier of the user or community to which the current comment was posted
     */
    get replyToUserId() {
        return this.payload.reply_to_user;
    }
    /**
     * Returns the identifier of the comment, in response to which the current is left
     */
    get replyToCommentId() {
        return this.payload.reply_to_comment;
    }
    /**
     * Returns the array of parent comment identifiers
     */
    get parentCommentIds() {
        return this.payload.parents_stack;
    }
    /**
     * Returns the post text
     */
    get text() {
        return this.payload.text;
    }
    /**
     * Returns the date when this post was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns information about a nested comment branch, an object with fields
     */
    get thread() {
        return this.payload.thread;
    }
}

class MarketAlbumAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.MARKET_ALBUM
        });
        this.$filled = this.payload.title !== undefined && this.payload.updated_time !== undefined;
        this.applyPayload(options.payload);
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const { items } = await this.api.market.getAlbumById({
            owner_id: this.ownerId,
            album_ids: this.id
        });
        this.$filled = true;
        this.applyPayload(items[0]);
    }
    /**
     * Returns album title
     */
    get title() {
        return this.payload.title;
    }
    /**
     * Returns count of products on the album
     */
    get count() {
        return this.payload.count;
    }
    /**
     * Returns the date when this album was updated
     */
    get updatedAt() {
        return this.payload.updated_time;
    }
    /**
     * Applies the payload
     */
    applyPayload(payload) {
        this.payload = payload;
        if (this.payload.photo) {
            this.photo = new PhotoAttachment({
                api: this.api,
                payload: this.payload.photo
            });
        }
    }
}

class AudioMessageAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(options) {
        super({
            ...options,
            type: exports.AttachmentType.AUDIO_MESSAGE
        });
        this.$filled = this.payload.duration !== undefined;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        const [document] = await this.api.docs.getById({
            docs: `${this.ownerId}_${this.id}`
        });
        this.payload = document;
        this.$filled = true;
    }
    /**
     * Returns the duration of the audio message
     */
    get duration() {
        return this.payload.duration;
    }
    /**
     * Returns the waveform of the audio message
     */
    get waveform() {
        return this.payload.waveform;
    }
    /**
     * Returns the ogg URL of the audio message
     */
    get oggUrl() {
        return this.payload.link_ogg;
    }
    /**
     * Returns the mp3 URL of the audio message
     */
    get mp3Url() {
        return this.payload.link_mp3;
    }
    /**
     * Returns the locale of the audio message
     */
    get locale() {
        return this.payload.locale;
    }
    /**
     * Returns the transcript of the audio message
     */
    get transcript() {
        return this.payload.transcript;
    }
    /**
     * Returns the transcript of the audio message
     */
    get transcriptState() {
        return this.payload.transcript_state;
    }
    /**
     * Returns the transcript of the audio message
     */
    get isTranscriptDone() {
        return this.payload.transcript_state === 'done';
    }
    /**
     * Returns the URL of the audio message
     */
    get url() {
        return this.mp3Url || this.oggUrl;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'duration',
            'oggUrl',
            'mp3Url',
            'url',
            'locale',
            'transcript',
            'isTranscriptDone'
        ]);
    }
}

class Context {
    /**
     * Constructor
     */
    constructor(options) {
        this.api = options.api;
        this.upload = options.upload;
        this.type = options.type;
        this.subTypes = options.subTypes;
        this.payload = options.payload;
        this.state = options.state || {};
        this.$groupId = options.groupId;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Checks whether the context of some of these types
     */
    is(rawTypes) {
        const types = !Array.isArray(rawTypes)
            ? [rawTypes]
            : rawTypes;
        if (types.includes(this.type)) {
            return true;
        }
        return this.subTypes.some((type) => (types.includes(type)));
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return {
            ...this[kSerializeData](),
            type: this.type,
            subTypes: this.subTypes,
            state: this.state
        };
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { api, upload, ...payload } = this;
        return payload;
    }
}
inspectable.inspectable(Context, {
    serialize: instance => instance.toJSON(),
    stringify: (instance, payload, context) => (`${context.stylize(instance.constructor.name, 'special')} ${context.inspect(payload)}`)
});

class UnsupportedEventContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'unsupported_event',
            subTypes: [
                options.updateType
            ],
            payload: options.payload
        });
    }
    /**
    * Event payload
    */
    get eventPayload() {
        return this.payload;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'eventPayload'
        ]);
    }
}

class VoteContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'vote',
            subTypes: [
                options.updateType
            ]
        });
    }
    /**
     * Returns the identifier poll
     */
    get id() {
        return this.payload.poll_id;
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the identifier owner
     */
    get ownerId() {
        return this.payload.owner_id;
    }
    /**
     * Returns the identifier option
     */
    get optionId() {
        return this.payload.option_id;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'id',
            'userId',
            'ownerId',
            'optionId'
        ]);
    }
}

class LikeContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'like',
            subTypes: [
                options.updateType
            ]
        });
    }
    /**
     * Returns the id of the user who interacts with the like
     */
    get likerId() {
        return this.payload.liker_id;
    }
    /**
     * Returns the material id
     */
    get objectId() {
        return this.payload.object_id;
    }
    /**
     * Returns the material owner id
     */
    get objectOwnerId() {
        return this.payload.object_owner_id;
    }
    /**
     * Returns the material type
     */
    get objectType() {
        return this.payload.object_type;
    }
    /**
     * Returns the post id (returned for a comment left under the post)
     */
    get postId() {
        return this.payload.post_id;
    }
    /**
     * Returns the parent comment / post id.
     */
    get threadReplyId() {
        return this.payload.thread_reply_id;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'likerId',
            'objectId',
            'objectOwnerId',
            'objectType',
            'postId',
            'threadReplyId'
        ]);
    }
}

exports.TypingState = void 0;
(function (TypingState) {
    TypingState["TYPING"] = "typing";
    TypingState["AUDIO_MESSAGE"] = "audiomessage";
    TypingState["PHOTO_MESSAGE"] = "photo";
    TypingState["VIDEO_MESSAGE"] = "video";
    TypingState["FILE_MESSAGE"] = "file";
})(exports.TypingState || (exports.TypingState = {}));
const stateTypesEnum = {
    63: exports.TypingState.TYPING,
    64: exports.TypingState.AUDIO_MESSAGE,
    65: exports.TypingState.PHOTO_MESSAGE,
    66: exports.TypingState.VIDEO_MESSAGE,
    67: exports.TypingState.FILE_MESSAGE
};
const transformPolling = ({ 1: toId, 2: fromIds }, updateType) => ({
    from_id: fromIds[0],
    to_id: toId,
    state: typeof updateType === 'string'
        ? updateType
        : stateTypesEnum[updateType]
});
class TypingContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'typing',
            subTypes: [
                'message_typing_state',
                `typing_${getPeerType(options.payload.from_id)}`
            ],
            payload: options.source === exports.UpdateSource.POLLING
                ? transformPolling(options.payload, options.updateType)
                : options.payload
        });
    }
    /**
     * Checks is typing
     */
    get isTyping() {
        return this.payload.state === exports.TypingState.TYPING;
    }
    /**
     * Checks is record audio message
     */
    get isAudioMessage() {
        return this.payload.state === exports.TypingState.AUDIO_MESSAGE;
    }
    /**
     * Checks is upload photo message
     */
    get isPhotoMessage() {
        return this.payload.state === exports.TypingState.PHOTO_MESSAGE;
    }
    /**
     * Checks is upload video message
     */
    get isVideoMessage() {
        return this.payload.state === exports.TypingState.VIDEO_MESSAGE;
    }
    /**
     * Checks is upload file message
     */
    get isFileMessage() {
        return this.payload.state === exports.TypingState.FILE_MESSAGE;
    }
    /**
     * Checks that the message is typed in the dm
     */
    get isUser() {
        return this.subTypes.includes('typing_user');
    }
    /**
     * Checks that the message is typed in the chat
     */
    get isGroup() {
        return this.subTypes.includes('typing_group');
    }
    /**
     * Checks that the message is typed in the chat
     */
    get isChat() {
        return this.chatId !== undefined;
    }
    /**
     * Returns the identifier sender
     */
    get fromId() {
        return this.payload.from_id;
    }
    /**
     * Returns the identifier destination
     */
    get toId() {
        return this.payload.to_id;
    }
    /**
     * Returns the identifier chat
     */
    get chatId() {
        const chatId = this.toId - PEER_CHAT_ID_OFFSET;
        return chatId > 0
            ? chatId
            : undefined;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'fromId',
            'toId',
            'chatId',
            'isUser',
            'isGroup',
            'isChat',
            'isTyping',
            'isAudioMessage',
            'isPhotoMessage',
            'isVideoMessage',
            'isFileMessage'
        ]);
    }
}

class CommentContext extends Context {
    constructor(options) {
        const initiator = options.updateType.substring(0, options.updateType.lastIndexOf('_'));
        super({
            ...options,
            type: 'comment',
            subTypes: [
                initiator,
                options.updateType
            ]
        });
        this.attachments = transformAttachments(this.payload.attachments || [], this.api);
    }
    /**
     * Checks is new comment
     */
    get isNew() {
        return this.includesFromSubType('new');
    }
    /**
     * Checks is edit comment
     */
    get isEdit() {
        return this.includesFromSubType('edit');
    }
    /**
     * Checks is delete comment
     */
    get isDelete() {
        return this.includesFromSubType('delete');
    }
    /**
     * Checks is restore comment
     */
    get isRestore() {
        return this.includesFromSubType('restore');
    }
    /**
     * Checks is photo comment
     */
    get isPhotoComment() {
        return this.includesFromSubType('photo');
    }
    /**
     * Checks is wall comment
     */
    get isWallComment() {
        return this.includesFromSubType('wall');
    }
    /**
     * Checks is video comment
     */
    get isVideoComment() {
        return this.includesFromSubType('video');
    }
    /**
     * Checks is board comment
     */
    get isBoardComment() {
        return this.includesFromSubType('board');
    }
    /**
     * Checks is board comment
     */
    get isMarketComment() {
        return this.includesFromSubType('market');
    }
    /**
     * Checks is reply comment
     */
    get isReply() {
        return this.payload.reply_to_comment !== undefined;
    }
    /**
     * Checks if the user wrote a message
     */
    get isUser() {
        return this.fromId > 0;
    }
    /**
     * Checks if the group wrote a message
     */
    get isGroup() {
        return this.fromId < 0;
    }
    /**
     * Returns the identifier comment
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the identifier reply comment
     */
    get replyId() {
        return this.payload.reply_to_comment;
    }
    /**
     * identifier of who wrote the comment
     */
    get fromId() {
        return (this.payload.from_id
            || this.payload.user_id);
    }
    /**
     * Returns the identifier reply user
     */
    get replyUserId() {
        return this.payload.reply_to_user;
    }
    /**
     * Returns the identifier of the user who deleted the comment
     */
    get deleterUserId() {
        return this.payload.deleter_id;
    }
    /**
     * Returns the identifier of object
     */
    get objectId() {
        const { payload } = this;
        return (payload.photo_id
            || payload.video_id
            || payload.post_id
            || payload.topic_id
            || payload.item_id);
    }
    /**
     * Returns the identifier of owner
     */
    get ownerId() {
        const { payload } = this;
        return (payload.owner_id
            || payload.photo_owner_id
            || payload.video_owner_id
            || payload.post_owner_id
            || payload.topic_owner_id
            || payload.market_owner_id);
    }
    /**
     * Returns the date creation action comment
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the text comment
     */
    get text() {
        return this.payload.text;
    }
    /**
     * Returns the likes
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get likes() {
        return this.payload.likes;
    }
    /**
     * Includes from subtype
     */
    includesFromSubType(type) {
        return this.subTypes[1].includes(type);
    }
    /**
     * Edits a comment
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    editComment(options) {
        if (this.isDelete) {
            return Promise.reject(new VKError({
                message: 'Comment is deleted',
                code: 'ALREADY_DELETED'
            }));
        }
        if (this.isBoardComment) {
            return this.api.board.editComment({
                ...options,
                comment_id: this.id,
                topic_id: this.objectId,
                group_id: this.$groupId
            });
        }
        const params = {
            ...options,
            comment_id: this.id,
            owner_id: this.ownerId
        };
        if (this.isPhotoComment) {
            return this.api.photos.editComment(params);
        }
        if (this.isVideoComment) {
            return this.api.video.editComment(params);
        }
        if (this.isWallComment) {
            return this.api.wall.editComment(params);
        }
        if (this.isMarketComment) {
            return this.api.market.editComment(params);
        }
        return Promise.reject(new VKError({
            message: 'Unsupported event for editing comment',
            code: 'UNSUPPORTED_EVENT'
        }));
    }
    /**
     * Removes comment
     */
    deleteComment() {
        if (this.isDelete) {
            return Promise.reject(new VKError({
                message: 'Comment is deleted',
                code: 'ALREADY_DELETED'
            }));
        }
        if (this.isBoardComment) {
            return this.api.board.deleteComment({
                comment_id: this.id,
                topic_id: this.objectId,
                group_id: this.$groupId
            });
        }
        const params = {
            comment_id: this.id,
            owner_id: this.ownerId
        };
        if (this.isPhotoComment) {
            return this.api.photos.deleteComment(params);
        }
        if (this.isVideoComment) {
            return this.api.video.deleteComment(params);
        }
        if (this.isWallComment) {
            return this.api.wall.deleteComment(params);
        }
        if (this.isMarketComment) {
            return this.api.market.deleteComment(params);
        }
        return Promise.reject(new VKError({
            message: 'Unsupported event for deleting comment',
            code: 'UNSUPPORTED_EVENT'
        }));
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        const properties = [
            'id',
            'replyId',
            'fromId',
            'replyUserId',
            'deleterUserId',
            'objectId',
            'ownerId',
            'createdAt',
            'text',
            'isNew',
            'isEdit',
            'isDelete',
            'isRestore',
            'isPhotoComment',
            'isWallComment',
            'isVideoComment',
            'isBoardComment',
            'isMarketComment',
            'isReply',
            'isUser',
            'isGroup',
            'likes'
        ];
        const filtredEmptyProperties = properties.filter(property => (this[property] !== undefined));
        return pickProperties(this, filtredEmptyProperties);
    }
}
applyMixins(CommentContext, [Attachmentable]);

const DocumentKind = {
    audiomsg: exports.AttachmentType.AUDIO_MESSAGE,
    graffiti: exports.AttachmentType.GRAFFITI // I know what is stupid
};
const idToAttachmentPayload = (key) => {
    const delimiterIndex = key.indexOf('_');
    return {
        id: Number(key.substring(delimiterIndex + 1)),
        owner_id: Number(key.substring(0, delimiterIndex))
    };
};
const attachmentHandlers = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sticker: (raw, key) => ({
        type: 'sticker',
        sticker: {
            sticker_id: Number(raw[key]),
            product_id: Number(raw[`${key}_product_id`])
        }
    }),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    money_transfer: (raw, key) => ({
        type: 'money_transfer',
        money_transfer: {
            data: raw[key],
            amount: Number(raw[`${key}_amount`]),
            currency: Number(raw[`${key}_currency`])
        }
    }),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    gift: (raw, key) => ({
        type: 'gift',
        gift: {
            id: Number(raw[key])
        }
    }),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    link: (raw, key) => {
        const photoId = raw[`${key}_photo`];
        return {
            type: 'link',
            link: {
                url: raw[`${key}_url`],
                title: raw[`${key}_title`],
                description: raw[`${key}_desc`],
                photo: photoId !== undefined
                    ? idToAttachmentPayload(photoId)
                    : undefined
            }
        };
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    doc: (raw, key, _, index) => {
        const type = DocumentKind[raw[`${key}_kind`]] || exports.AttachmentType.DOCUMENT;
        if (type in DocumentKind) {
            return JSON.parse(raw.attachments)[index - 1];
        }
        return {
            type,
            [type]: idToAttachmentPayload(raw[key])
        };
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    default: (raw, key, type) => ({
        type,
        [type]: idToAttachmentPayload(raw[key])
    })
};
/**
 * Transform message to Object
 */
function transformMessage({ 1: id, 2: flags, 3: peer_id, 4: date, 5: text, 6: extra, 7: attachments, 8: random_id, 9: conversation_message_id, 10: update_time
// eslint-disable-next-line @typescript-eslint/no-explicit-any
 }) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const message = {
        id,
        conversation_message_id,
        peer_id,
        date,
        update_time,
        text,
        random_id,
        geo: attachments.geo !== undefined
            ? {}
            : undefined,
        payload: extra.payload
    };
    if (extra.from !== undefined) {
        message.from_id = Number(extra.from);
    }
    else {
        message.from_id = peer_id;
    }
    if (peer_id < 0 && message.peer_id !== message.from_id) {
        // eslint-disable-next-line no-bitwise
        message.out = Number((flags & 2) === 0);
        // eslint-disable-next-line no-bitwise
        message.important = (flags & 1) !== 0;
    }
    else {
        // eslint-disable-next-line no-bitwise
        message.out = Number((flags & 2) !== 0);
        // eslint-disable-next-line no-bitwise
        message.important = (flags & 8) !== 0;
    }
    if (extra.source_act !== undefined) {
        message.action = {
            type: extra.source_act,
            text: extra.source_message,
            member_id: extra.source_mid
                ? Number(extra.source_mid)
                : undefined
        };
    }
    message.attachments = [];
    for (let i = 1, key = 'attach1'; attachments[key] !== undefined; i += 1, key = `attach${i}`) {
        const type = attachments[`${key}_type`];
        const handler = attachmentHandlers[type]
            || attachmentHandlers.default;
        message.attachments.push(handler(attachments, key, type, i));
    }
    if (attachments.reply !== undefined) {
        const reply = JSON.parse(attachments.reply);
        message.reply_message = {
            id: 0,
            conversation_message_id: reply.conversation_message_id,
            date: 0,
            update_time: 0,
            from_id: 0,
            peer_id: 0,
            out: 0,
            text: '',
            fwd_messages: [],
            attachments: [],
            random_id: 0,
            important: false
        };
    }
    else if (attachments.fwd !== undefined) {
        message.fwd_messages = [{
                id: 0,
                conversation_message_id: 0,
                date: 0,
                update_time: 0,
                from_id: 0,
                peer_id: 0,
                out: 0,
                text: '',
                fwd_messages: [],
                attachments: [],
                random_id: 0,
                important: false
            }];
    }
    return message;
}

/* eslint-disable max-classes-per-file */
const subTypesEnum = {
    4: 'message_new',
    5: 'message_edit',
    18: 'message_edit'
};
const kForwards = Symbol('forwards');
const kReplyMessage = Symbol('replyMessage');
const kMessagePayload = Symbol('messagePayload');
const kAttachments = Symbol('attachments');
class MessageContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'message',
            subTypes: []
        });
        if (options.source === exports.UpdateSource.POLLING) {
            this.$filled = false;
            this.applyPayload(Array.isArray(options.payload)
                ? transformMessage(options.payload)
                // There's user long poll reply message
                : options.payload);
        }
        else {
            this.$filled = true;
            this.applyPayload(options.payload);
        }
        this.subTypes = [
            this.eventType
                || subTypesEnum[options.updateType]
                || options.updateType
        ];
    }
    /**
     * Load message payload
     */
    async loadMessagePayload({ force = false } = {}) {
        if (this.$filled && !force) {
            return;
        }
        const { items } = this.id !== 0
            ? await this.api.messages.getById({
                message_ids: this.id
            })
            : await this.api.messages.getByConversationMessageId({
                peer_id: this.peerId,
                conversation_message_ids: this.conversationMessageId
            });
        const [message] = items;
        this.applyPayload(message);
        this.$filled = true;
    }
    /**
     * Checks if there is text
     */
    get hasText() {
        return Boolean(this.text);
    }
    /**
     * Checks for reply message
     */
    get hasReplyMessage() {
        return this.replyMessage !== undefined;
    }
    /**
     * Checks for forwarded messages
     */
    get hasForwards() {
        return this.forwards.length > 0;
    }
    /**
     * Checks for hast message payload
     */
    get hasMessagePayload() {
        return Boolean(this.message.payload);
    }
    /**
     * Checks if there is text
     */
    get hasGeo() {
        return Boolean(this.message.geo);
    }
    /**
     * Checks is a chat
     */
    get isChat() {
        return this.peerType === exports.MessageSource.CHAT;
    }
    /**
     * Check is a user
     */
    get isUser() {
        return this.senderType === exports.MessageSource.USER;
    }
    /**
     * Checks is a group
     */
    get isGroup() {
        return this.senderType === exports.MessageSource.GROUP;
    }
    /**
     * Checks is from the user
     */
    get isFromUser() {
        return this.peerType === exports.MessageSource.USER;
    }
    /**
     * Checks is from the group
     */
    get isFromGroup() {
        return this.peerType === exports.MessageSource.GROUP;
    }
    /**
     * Checks a message has arrived in direct messages
     */
    get isDM() {
        return this.isFromUser || this.isFromGroup;
    }
    /**
     * Check is special event
     */
    get isEvent() {
        return this.eventType !== undefined;
    }
    /**
     * Checks whether the message is outbox
     */
    get isOutbox() {
        return Boolean(this.message.out);
    }
    /**
     * Checks whether the message is inboxed
     */
    get isInbox() {
        return !this.isOutbox;
    }
    /**
     * Checks that the message is important
     */
    get isImportant() {
        return this.message.important;
    }
    /**
     * Returns the identifier message
     */
    get id() {
        return this.message.id;
    }
    /**
     * Returns the conversation message id
     */
    get conversationMessageId() {
        return this.message.conversation_message_id;
    }
    /**
     * Returns the destination identifier
     */
    get peerId() {
        return this.message.peer_id;
    }
    /**
     * Returns the peer type
     */
    get peerType() {
        return getPeerType(this.message.peer_id);
    }
    /**
     * Returns the sender identifier
     */
    get senderId() {
        return this.message.from_id;
    }
    /**
     * Returns the sender type
     */
    get senderType() {
        return getPeerType(this.message.from_id);
    }
    /**
     * Returns the identifier chat
     */
    get chatId() {
        if (!this.isChat) {
            return undefined;
        }
        return this.peerId - PEER_CHAT_ID_OFFSET;
    }
    /**
     * Returns the referral value
     */
    get referralValue() {
        return this.message.ref;
    }
    /**
     * Returns the referral source
     */
    get referralSource() {
        return this.message.ref_source;
    }
    /**
     * Returns the date when this message was created
     */
    get createdAt() {
        return this.message.date;
    }
    /**
     * Returns the date when this message was updated
     */
    get updatedAt() {
        return this.message.update_time;
    }
    /**
     * Returns geo
     */
    get geo() {
        if (!this.hasGeo || !this.$filled) {
            return undefined;
        }
        return this.message.geo;
    }
    /**
     * Returns the sender (admin community) identifier, only for community messages
     */
    get adminAuthorId() {
        return this.message.admin_author_id;
    }
    /**
     * Checks whether the message is cropped for bot
     */
    get isCropped() {
        return this.message.is_cropped;
    }
    /**
     * Returns the members count
     */
    get membersCount() {
        return this.message.members_count;
    }
    /**
     * Checks whether the attached audio message has already been listened by you
     */
    get wasListened() {
        return this.message.was_listened;
    }
    /**
     * Returns the date when this message was pinned
     */
    get pinnedAt() {
        return this.message.pinned_at;
    }
    /**
     * Returns the string for matching user Notify and VK
     */
    get messageTag() {
        return this.message.message_tag;
    }
    /**
     * Checks whether the message is expired
     */
    get isExpired() {
        return this.message.is_expired;
    }
    /**
     * Returns the event name
     */
    get eventType() {
        var _a;
        return (_a = this.message.action) === null || _a === void 0 ? void 0 : _a.type;
    }
    /**
     * Returns the event member id
     */
    get eventMemberId() {
        var _a;
        return (_a = this.message.action) === null || _a === void 0 ? void 0 : _a.member_id;
    }
    /**
     * Returns the event name
     */
    get eventText() {
        var _a;
        return (_a = this.message.action) === null || _a === void 0 ? void 0 : _a.text;
    }
    /**
     * Returns the event email
     */
    get eventEmail() {
        var _a;
        return (_a = this.message.action) === null || _a === void 0 ? void 0 : _a.email;
    }
    /**
     * Returns the message payload
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get messagePayload() {
        return this[kMessagePayload];
    }
    /**
     * Returns the forwards
     */
    get forwards() {
        return this[kForwards];
    }
    /**
     * Returns the reply message
     */
    get replyMessage() {
        return this[kReplyMessage];
    }
    /**
     * Returns the attachments
     */
    get attachments() {
        return this[kAttachments];
    }
    /**
     * Returns the capabilities of the client the user is using.
     */
    get clientInfo() {
        return this.payload.client_info;
    }
    /**
     * Edits a message
     */
    editMessage(params) {
        const target = this.id !== 0
            ? { message_id: this.id }
            : { conversation_message_id: this.conversationMessageId };
        return this.api.messages.edit({
            attachment: String(this.attachments.filter(attachment => (attachment.canBeAttached))),
            message: this.text,
            keep_forward_messages: 1,
            keep_snippets: 1,
            ...params,
            ...target,
            peer_id: this.peerId
        });
    }
    /**
     * Sends a message to the current dialog
     */
    async send(text, params) {
        const randomId = getRandomId();
        const options = {
            random_id: randomId,
            ...(typeof text !== 'object'
                ? {
                    message: text,
                    ...params
                }
                : text)
        };
        if (this.$groupId !== undefined) {
            options.peer_ids = this.peerId;
        }
        else {
            options.peer_id = this.peerId;
        }
        const rawDestination = await this.api.messages.send(options);
        const { message } = this;
        const destination = typeof rawDestination !== 'number'
            ? rawDestination[0]
            : {
                peer_id: message.peer_id,
                message_id: rawDestination,
                conversation_message_id: 0
            };
        const messageContext = new MessageContext({
            api: this.api,
            upload: this.upload,
            source: exports.UpdateSource.WEBHOOK,
            groupId: this.$groupId,
            updateType: 'message_new',
            state: this.state,
            payload: {
                client_info: this.clientInfo,
                message: {
                    id: destination.message_id,
                    conversation_message_id: destination.conversation_message_id,
                    // TODO: This must be the bot identifier
                    from_id: message.from_id,
                    peer_id: destination.peer_id,
                    out: 1,
                    important: false,
                    random_id: randomId,
                    text: options.text,
                    date: Math.floor(Date.now() / 1000),
                    attachments: []
                }
            }
        });
        messageContext.$filled = false;
        return messageContext;
    }
    /**
     * Responds to the current message
     */
    reply(text, params) {
        const forwardOptions = this.conversationMessageId
            ? { conversation_message_ids: this.conversationMessageId }
            : { message_ids: this.id };
        return this.send({
            forward: JSON.stringify({
                ...forwardOptions,
                peer_id: this.peerId,
                is_reply: true
            }),
            ...(typeof text !== 'object'
                ? {
                    message: text,
                    ...params
                }
                : text)
        });
    }
    /**
     * Sends a photos to the current dialog
     */
    async sendPhotos(rawSources, params = {}) {
        const sources = !Array.isArray(rawSources)
            ? [rawSources]
            : rawSources;
        const attachment = await Promise.all(sources.map(source => (this.upload.messagePhoto({
            source,
            peer_id: this.peerId
        }))));
        return this.send({
            ...params,
            attachment
        });
    }
    /**
     * Sends a documents to the current dialog
     */
    async sendDocuments(rawSources, params = {}) {
        const sources = !Array.isArray(rawSources)
            ? [rawSources]
            : rawSources;
        const attachment = await Promise.all(sources.map(source => (this.upload.messageDocument({
            source,
            peer_id: this.peerId
        }))));
        return this.send({
            ...params,
            attachment
        });
    }
    /**
     * Sends an audio message to the current dialog
     */
    async sendAudioMessage(source, params = {}) {
        const attachment = await this.upload.audioMessage({
            source,
            peer_id: this.peerId
        });
        return this.send({
            ...params,
            attachment
        });
    }
    /**
     * Changes the status of typing in the dialog
     */
    async setActivity() {
        const isActivited = await this.api.messages.setActivity({
            peer_id: this.peerId,
            type: 'typing'
        });
        return Boolean(isActivited);
    }
    /**
     * Deletes the message
     */
    async deleteMessage(options = {}) {
        const isConversation = Boolean(this.conversationMessageId);
        const target = isConversation
            ? { peer_id: this.peerId, cmids: this.conversationMessageId }
            : { message_ids: this.id };
        const messageIds = await this.api.messages.delete({
            ...options,
            ...target
        });
        return Boolean(messageIds[isConversation ? this.conversationMessageId : this.id]);
    }
    /**
     * Restores the message
     */
    async restoreMessage() {
        const isRestored = await this.api.messages.restore({
            message_id: this.id
        });
        return Boolean(isRestored);
    }
    /**
     * Return alias of payload.message
     */
    get message() {
        return this.payload.message;
    }
    /**
     * Applies the payload
     */
    applyPayload(payload) {
        // Polyfill for all events except new_message
        this.payload = !('client_info' in payload)
            ? {
                message: payload,
                client_info: {
                    button_actions: [
                        'text'
                    ],
                    inline_keyboard: false,
                    keyboard: true,
                    carousel: false,
                    lang_id: 0
                }
            }
            : payload;
        const { message } = this;
        this.text = message.text
            ? unescapeHTML(message.text)
            : undefined;
        this[kAttachments] = transformAttachments(message.attachments || [], this.api);
        if (message.reply_message) {
            const replyPeerId = message.reply_message.peer_id || 0;
            this[kReplyMessage] = new MessageContext({
                api: this.api,
                upload: this.upload,
                source: this.$filled
                    ? exports.UpdateSource.WEBHOOK
                    : exports.UpdateSource.POLLING,
                groupId: this.$groupId,
                updateType: 'message_new',
                state: this.state,
                payload: {
                    client_info: this.clientInfo,
                    message: {
                        ...message.reply_message,
                        peer_id: replyPeerId !== 0
                            ? replyPeerId
                            : this.peerId
                    }
                }
            });
        }
        this[kForwards] = new MessageForwardsCollection(...(message.fwd_messages || []).map(forward => (new MessageContext({
            api: this.api,
            upload: this.upload,
            source: exports.UpdateSource.WEBHOOK,
            groupId: this.$groupId,
            updateType: 'message_new',
            state: this.state,
            payload: {
                client_info: this.clientInfo,
                message: forward
            }
        }))));
        if (message.payload) {
            this[kMessagePayload] = JSON.parse(message.payload);
        }
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        const beforeAttachments = [];
        if (this.isEvent) {
            beforeAttachments.push('eventType', 'eventMemberId', 'eventText', 'eventEmail');
        }
        if (this.hasReplyMessage) {
            beforeAttachments.push('replyMessage');
        }
        const afterAttachments = [];
        if (this.hasMessagePayload) {
            afterAttachments.push('messagePayload');
        }
        if (this.hasGeo) {
            afterAttachments.push('geo');
        }
        afterAttachments.push('isOutbox');
        if (this.referralSource || this.referralValue) {
            afterAttachments.push('referralValue', 'referralSource');
        }
        if (this.$match) {
            afterAttachments.push('$match');
        }
        return pickProperties(this, [
            'id',
            'conversationMessageId',
            'peerId',
            'peerType',
            'senderId',
            'senderType',
            'createdAt',
            'updatedAt',
            'pinnedAt',
            'text',
            ...beforeAttachments,
            'forwards',
            'attachments',
            ...afterAttachments
        ]);
    }
}
applyMixins(MessageContext, [
    Attachmentable,
    class AllAttachmentable extends Attachmentable {
        hasAllAttachments(type) {
            var _a;
            return (this.hasAttachments(type)
                || ((_a = this.replyMessage) === null || _a === void 0 ? void 0 : _a.hasAttachments(type))
                || this.forwards.hasAttachments(type));
        }
        getAllAttachments(type) {
            var _a, _b;
            return [
                // @ts-expect-error
                ...this.getAttachments(type),
                // @ts-expect-error
                ...((_b = ((_a = this.replyMessage) === null || _a === void 0 ? void 0 : _a.getAttachments(type))) !== null && _b !== void 0 ? _b : []),
                // @ts-expect-error
                ...this.forwards.getAttachments(type)
            ];
        }
    }
]);

class WallPostContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'wall_post',
            subTypes: [
                options.updateType
            ]
        });
        this.wall = new WallAttachment({
            api: this.api,
            payload: this.payload
        });
    }
    /**
     * Checks is repost
     */
    get isRepost() {
        return this.subTypes.includes('wall_repost');
    }
    /**
     * Removes a record from the wall
     */
    deletePost() {
        const { wall } = this;
        return this.api.wall.delete({
            post_id: wall.id,
            owner_id: wall.ownerId
        });
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'wall',
            'isRepost'
        ]);
    }
}

/**
 * Causes of blocking
 */
const reasonNames = new Map([
    [0, 'other'],
    [1, 'spam'],
    [2, 'members_insult'],
    [3, 'obscene_expressions'],
    [4, 'messages_off_topic']
]);
class GroupUserContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'group_user',
            subTypes: [
                options.updateType
            ]
        });
    }
    /**
     * Checks is join user
     */
    get isBlocked() {
        return this.subTypes.includes('user_block');
    }
    /**
     * Checks is leave user
     */
    get isUnblocked() {
        return this.subTypes.includes('user_unblock');
    }
    /**
     * Checks that the block has expired
     */
    get isExpired() {
        if (this.isBlocked) {
            return undefined;
        }
        return Boolean(this.payload.by_end_date);
    }
    /**
     * Returns the identifier admin
     */
    get adminId() {
        return this.payload.admin_id;
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the reason for the ban
     */
    get reasonId() {
        return this.payload.reason;
    }
    /**
     * Returns the reason name for the ban
     */
    get reasonName() {
        return reasonNames.get(this.reasonId);
    }
    /**
     * Returns unblock date or undefined if permanent
     */
    get unblockAt() {
        return this.payload.unblock_date;
    }
    /**
     * Returns the administrator comment to block
     */
    get comment() {
        return this.payload.comment;
    }
    /**
     * Adds a user to the community blacklist
     */
    ban(params) {
        if (this.isBlocked) {
            return Promise.reject(new VKError({
                message: 'User is blocked',
                code: 'ALREADY_BANNED'
            }));
        }
        return this.api.groups.ban({
            ...params,
            group_id: this.$groupId,
            user_id: this.userId
        });
    }
    /**
     * Adds a user to the community blacklist
     */
    unban() {
        if (this.isUnblocked) {
            return Promise.reject(new VKError({
                message: 'User is not blocked',
                code: 'ALREADY_UNBANNED'
            }));
        }
        return this.api.groups.unban({
            group_id: this.$groupId,
            user_id: this.userId
        });
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'adminId',
            'userId',
            'reasonId',
            'reasonName',
            'comment',
            'isExpired',
            'isBlocked',
            'isUnblocked'
        ]);
    }
}

const subTypes$4 = {
    10: 'dialog_flags_delete',
    11: 'dialog_flags_replace',
    12: 'dialog_flags_add'
};
/* eslint-disable no-bitwise */
var DialogFlag;
(function (DialogFlag) {
    DialogFlag[DialogFlag["IMPORTANT"] = 1] = "IMPORTANT";
    DialogFlag[DialogFlag["UNANSWERED"] = 2] = "UNANSWERED";
})(DialogFlag || (DialogFlag = {}));
class DialogFlagsContext extends Context {
    constructor(options) {
        const [eventId, peerId, flags] = options.payload;
        super({
            ...options,
            type: 'dialog_flags',
            subTypes: [
                subTypes$4[eventId]
            ],
            payload: {
                peer_id: peerId,
                flags
            }
        });
    }
    /**
     * Checks if dialogue is important
     */
    get isImportant() {
        return this.hasFlag(DialogFlag.IMPORTANT);
    }
    /**
     * Checks if the dialog is unanswered
     */
    get isUnanswered() {
        return this.hasFlag(DialogFlag.UNANSWERED);
    }
    /**
     * Returns the destination identifier
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the values of the flags
     */
    get flags() {
        return this.payload.flags;
    }
    /**
     * Marks the conversation as answered or unchecked
     */
    markAsAnsweredConversation(params) {
        return this.api.messages.markAsAnsweredConversation({
            ...params,
            peer_id: this.peerId
        });
    }
    /**
     * Marks the conversation as important or removes the mark
     */
    markAsImportantConversation(params) {
        return this.api.messages.markAsImportantConversation({
            ...params,
            peer_id: this.peerId
        });
    }
    hasFlag(flag) {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & flag);
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'peerId',
            'flags',
            'isImportant',
            'isUnanswered'
        ]);
    }
}

class MarketOrderContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'market_order',
            subTypes: [
                options.updateType
            ]
        });
        this.previewOrderItems = this.payload.preview_order_items.map(market => (new MarketAttachment({
            api: this.api,
            payload: market
        })));
    }
    /**
     * Checks if the variation is the primary one.
     */
    get isMainVariant() {
        return Boolean(this.payload.is_main_variant);
    }
    /**
     * Returns the order identifier
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the group identifier
     */
    get groupId() {
        return this.payload.group_id;
    }
    /**
     * Returns the user identifier
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the order number consisting of the customer identifier and the order identifier.
     */
    get displayOrderId() {
        return this.payload.display_order_id;
    }
    /**
     * Returns the identifier of the variation group
     */
    get variantsGroupingId() {
        return this.payload.variants_grouping_id;
    }
    /**
     * Returns the properties of a variant
     */
    get propertyValues() {
        return this.payload.property_values;
    }
    /**
     * Returns the number of items in the cart
     */
    get cartQuantity() {
        return this.payload.cart_quantity;
    }
    /**
     * Returns order status
     *
     * `0` - New
     *
     * `1` - Agreed
     *
     * `2` - Going
     *
     * `3` - Delivered
     *
     * `4` - Completed
     *
     * `5` - Canceled
     *
     * `6` - Returned
     */
    get status() {
        return this.payload.status;
    }
    /**
     * Returns the total order value.
     */
    get totalPrice() {
        return this.payload.total_price;
    }
    /**
     * Returns a comment for the order
     */
    get commentText() {
        return this.payload.comment;
    }
    /**
     * Returns shipping information
     */
    get delivery() {
        return this.payload.delivery;
    }
    /**
     * Returns customer information
     */
    get recipient() {
        return this.payload.recipient;
    }
    /**
     * Returns the date when this order was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'id',
            'groupId',
            'userId',
            'displayOrderId',
            'variantsGroupingId',
            'propertyValues',
            'cartQuantity',
            'status',
            'totalPrice',
            'commentText',
            'previewOrderItems',
            'delivery',
            'recipient',
            'createdAt'
        ]);
    }
}

class GroupUpdateContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'group_update',
            subTypes: [
                options.updateType
            ]
        });
        this.attachments = options.updateType === 'group_change_photo'
            ? [new PhotoAttachment({
                    api: this.api,
                    payload: this.payload.photo
                })]
            : [];
    }
    /**
     * Checks is change photo
     */
    get isChangePhoto() {
        return this.subTypes.includes('group_change_photo');
    }
    /**
     * Checks is change officers
     */
    get isChangeOfficers() {
        return this.subTypes.includes('group_officers_edit');
    }
    /**
     * Checks is change settings
     */
    get isChangeSettings() {
        return this.subTypes.includes('group_change_settings');
    }
    /**
     * Returns the identifier admin
     */
    get adminId() {
        return this.payload.admin_id;
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the old level permission
     */
    get oldLevel() {
        return this.payload.level_old;
    }
    /**
     * Returns the new level permission
     */
    get newLevel() {
        return this.payload.level_new;
    }
    /**
     * Returns the changes settings
     */
    get changes() {
        return this.payload.changes;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'adminId',
            'userId',
            'oldLevel',
            'newLevel',
            'changes',
            'attachments'
        ]);
    }
}
applyMixins(GroupUpdateContext, [Attachmentable]);

class GroupMemberContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'group_member',
            subTypes: [
                options.updateType
            ]
        });
    }
    /**
     * Checks is join user
     */
    get isJoin() {
        return this.subTypes.includes('group_join');
    }
    /**
     * Checks is leave user
     */
    get isLeave() {
        return this.subTypes.includes('group_leave');
    }
    /**
     * Checks is self leave user
     */
    get isSelfLeave() {
        if (this.isJoin) {
            return undefined;
        }
        return Boolean(this.payload.self);
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the join type
     */
    get joinType() {
        if (this.isLeave) {
            return undefined;
        }
        return this.payload.join_type;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'userId',
            'joinType',
            'isJoin',
            'isLeave',
            'isSelfLeave'
        ]);
    }
}

class MessageEventContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'message_event',
            subTypes: [
                options.updateType
            ]
        });
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the conversation message id
     */
    get conversationMessageId() {
        return this.payload.conversation_message_id;
    }
    /**
     * Returns the destination identifier
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns a random string. Active for a minute, after a minute becomes invalid
     */
    get eventId() {
        return this.payload.event_id;
    }
    /**
     * Returns the event payload
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get eventPayload() {
        return this.payload.payload;
    }
    /**
     * Dispatches an event with an action that will occur when the callback button is pressed
     */
    answer(eventData) {
        return this.api.messages.sendMessageEventAnswer({
            event_id: this.eventId,
            peer_id: this.peerId,
            user_id: this.userId,
            event_data: JSON.stringify(eventData)
        });
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'userId',
            'conversationMessageId',
            'peerId',
            'eventId',
            'eventPayload'
        ]);
    }
}

const subTypes$3 = {
    6: 'messages_read_inbox',
    7: 'messages_read_outbox'
};
class MessagesReadContext extends Context {
    constructor(options) {
        const [eventId, peerId, localId] = options.payload;
        super({
            ...options,
            type: 'messages_read',
            subTypes: [
                subTypes$3[eventId]
            ],
            payload: {
                peer_id: peerId,
                local_id: localId
            }
        });
    }
    /**
     * Checks that inbox messages are read
     */
    get isInbox() {
        return this.subTypes.includes('messages_read_inbox');
    }
    /**
     * Checks that outbox messages are read
     */
    get isOutbox() {
        return this.subTypes.includes('messages_read_outbox');
    }
    /**
     * Returns the peer ID
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the identifier of the local message
     */
    get localId() {
        return this.payload.local_id;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'id',
            'peerId',
            'isInbox',
            'isOutbox'
        ]);
    }
}

const subTypes$2 = {
    1: 'message_flags_replace',
    2: 'message_flags_add',
    3: 'message_flags_delete'
};
/* eslint-disable no-bitwise */
var MessageFlag;
(function (MessageFlag) {
    MessageFlag[MessageFlag["UNREAD"] = 1] = "UNREAD";
    MessageFlag[MessageFlag["OUTBOX"] = 2] = "OUTBOX";
    MessageFlag[MessageFlag["IMPORTANT"] = 8] = "IMPORTANT";
    MessageFlag[MessageFlag["FROM_WEB_CHAT"] = 16] = "FROM_WEB_CHAT";
    MessageFlag[MessageFlag["FRIEND_MESSAGE"] = 32] = "FRIEND_MESSAGE";
    MessageFlag[MessageFlag["MARK_SPAM"] = 64] = "MARK_SPAM";
    MessageFlag[MessageFlag["DEL\u0415T\u0415D"] = 128] = "DEL\u0415T\u0415D";
    MessageFlag[MessageFlag["AUDIO_MESSAGE_LISTENED"] = 4096] = "AUDIO_MESSAGE_LISTENED";
    MessageFlag[MessageFlag["FROM_CLIENT_CHAT"] = 8192] = "FROM_CLIENT_CHAT";
    MessageFlag[MessageFlag["UNMARK_SPAM"] = 32768] = "UNMARK_SPAM";
    MessageFlag[MessageFlag["HIDDEN"] = 65536] = "HIDDEN";
    MessageFlag[MessageFlag["DELETED_FOR_ALL"] = 131072] = "DELETED_FOR_ALL";
    MessageFlag[MessageFlag["INBOX_FROM_CHAT"] = 524288] = "INBOX_FROM_CHAT";
    MessageFlag[MessageFlag["SILENT"] = 1048576] = "SILENT";
    MessageFlag[MessageFlag["REPLIED"] = 2097152] = "REPLIED";
})(MessageFlag || (MessageFlag = {}));
class MessageFlagsContext extends Context {
    constructor(options) {
        const [eventId, id, flags, peerId] = options.payload;
        super({
            ...options,
            type: 'message_flags',
            subTypes: [
                subTypes$2[eventId]
            ],
            payload: {
                peer_id: peerId,
                flags,
                id
            }
        });
        if (options.payload.length > 4) {
            this.message = new MessageContext({
                api: this.api,
                upload: this.upload,
                source: exports.UpdateSource.POLLING,
                updateType: 4,
                // @ts-expect-error
                payload: options.payload
            });
        }
    }
    /**
     * Checks if a message is unread
     */
    get isUnread() {
        return this.hasFlag(MessageFlag.UNREAD);
    }
    /**
     * Checks if a message is outbox
     */
    get isOutbox() {
        return this.hasFlag(MessageFlag.OUTBOX);
    }
    /**
     * Checks if a message is important
     */
    get isImportant() {
        return this.hasFlag(MessageFlag.IMPORTANT);
    }
    /**
     * Checks if a message was sent from a web chat
     */
    get isFromWebChat() {
        return this.hasFlag(MessageFlag.FROM_WEB_CHAT);
    }
    /**
     * Checks whether a message has been sent or received from a friend
     */
    get isFriendMessage() {
        return this.hasFlag(MessageFlag.FRIEND_MESSAGE);
    }
    /**
     * Check if a message is marked as spam
     */
    get isMarkSpam() {
        return this.hasFlag(MessageFlag.MARK_SPAM);
    }
    /**
     * Check if the message was deleted locally
     */
    get isDeleted() {
        return this.hasFlag(MessageFlag.DELЕTЕD);
    }
    /**
     * Checks if an audio message has been listened
     */
    get isAudioMessageListened() {
        return this.hasFlag(MessageFlag.AUDIO_MESSAGE_LISTENED);
    }
    /**
     * Checks if a message was sent from a client
     */
    get isFromClientChat() {
        return this.hasFlag(MessageFlag.FROM_CLIENT_CHAT);
    }
    /**
     * Check if message is unmarked as spam
     */
    get isUnmarkSpam() {
        return this.hasFlag(MessageFlag.UNMARK_SPAM);
    }
    /**
     * Checks if it's a welcome message from the group
     */
    get isHidden() {
        return this.hasFlag(MessageFlag.HIDDEN);
    }
    /**
     * Check if the message was deleted for all
     */
    get isDeletedForAll() {
        return this.hasFlag(MessageFlag.DELETED_FOR_ALL);
    }
    /**
     * Checks if the message is inbox from chat
     */
    get isInboxFromChat() {
        return this.hasFlag(MessageFlag.INBOX_FROM_CHAT);
    }
    /**
     * Checks if the message is silent (without notifications)
     */
    get isSilent() {
        return this.hasFlag(MessageFlag.SILENT);
    }
    /**
     * Checks a reply has been created to the message
     */
    get isReplied() {
        return this.hasFlag(MessageFlag.REPLIED);
    }
    /**
     * Returns the message ID
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the destination identifier
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the values of the flags
     */
    get flags() {
        return this.payload.flags;
    }
    hasFlag(flag) {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & flag);
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'id',
            'peerId',
            'flags',
            'message',
            'isUnread',
            'isOutbox',
            'isImportant',
            'isFromWebChat',
            'isFriendMessage',
            'isMarkSpam',
            'isDeleted',
            'isAudioMessageListened',
            'isFromClientChat',
            'isUnmarkSpam',
            'isHidden',
            'isDeletedForAll',
            'isInboxFromChat',
            'isSilent',
            'isReplied'
        ]);
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
class VKAppPayloadContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'vk_app_event',
            subTypes: [
                options.updateType
            ]
        });
    }
    /**
     * Returns the identifier of the user whose action the event was sent to in the application
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the identifier of the application from which the event was sent
     */
    get appId() {
        return this.payload.app_id;
    }
    /**
     * Returns the identifier of the community to which the notification was sent
     */
    get groupId() {
        return this.payload.group_id;
    }
    /**
     * Returns the transferred useful data
     */
    get eventPayload() {
        return JSON.parse(this.payload.payload);
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'userId',
            'appId',
            'groupId',
            'eventPayload'
        ]);
    }
}

class DonutWithdrawContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'donut_withdraw',
            subTypes: [
                options.updateType
            ]
        });
    }
    /**
     * Checks if error for withdraw
     */
    get isError() {
        return this.is(['donut_money_withdraw_error']);
    }
    /**
     * Returns the amount
     */
    get amount() {
        return this.payload.amount;
    }
    /**
     * Returns the amount without fee
     */
    get amountWithoutFee() {
        return this.payload.amount_without_fee;
    }
    /**
     * Returns the reason for the error
     */
    get reason() {
        return this.payload.reason;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'isError',
            'amount',
            'amountWithoutFee',
            'reason'
        ]);
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const subAttachmentTypes = {
    photo_new: PhotoAttachment,
    video_new: VideoAttachment,
    audio_new: AudioAttachment
};
class NewAttachmentsContext extends Context {
    constructor(options) {
        const PayloadAttachment = subAttachmentTypes[options.updateType];
        super({
            ...options,
            type: 'new_attachment',
            subTypes: [
                options.updateType
            ]
        });
        this.attachments = [new PayloadAttachment(this.payload, this.api)];
    }
    /**
     * Checks is attachment photo
     */
    get isPhoto() {
        return this.subTypes.includes('photo_new');
    }
    /**
     * Checks is attachment video
     */
    get isVideo() {
        return this.subTypes.includes('video_new');
    }
    /**
     * Checks is attachment audio
     */
    get isAudio() {
        return this.subTypes.includes('audio_new');
    }
    /**
     * Removes the attachment
     */
    deleteAttachment() {
        if (this.isPhoto) {
            const [photo] = this.getAttachments(exports.AttachmentType.PHOTO);
            return this.api.photos.delete({
                owner_id: photo.ownerId,
                photo_id: photo.id
            });
        }
        if (this.isVideo) {
            const [video] = this.getAttachments(exports.AttachmentType.VIDEO);
            return this.api.video.delete({
                owner_id: video.ownerId,
                video_id: video.id
            });
        }
        if (this.isAudio) {
            const [audio] = this.getAttachments(exports.AttachmentType.AUDIO);
            // @ts-expect-error
            return this.api.audio.delete({
                owner_id: audio.ownerId,
                audio_id: audio.id
            });
        }
        return Promise.reject(new VKError({
            message: 'Unsupported event for deleting attachment',
            code: 'UNSUPPORTED_EVENT'
        }));
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'attachments',
            'isPhoto',
            'isVideo',
            'isAudio'
        ]);
    }
}
applyMixins(NewAttachmentsContext, [Attachmentable]);

const subTypes$1 = {
    8: 'friend_online',
    9: 'friend_offline',
    81: 'friend_invisible'
};
class FriendActivityContext extends Context {
    constructor(options) {
        const [eventId, userId, extra, date, appId] = options.payload;
        super({
            ...options,
            type: 'friend_activity',
            subTypes: [
                subTypes$1[eventId]
            ],
            payload: {
                user_id: -userId,
                extra,
                date,
                app_id: appId
            }
        });
    }
    /**
     * Checks that the user is online
     */
    get isOnline() {
        return this.subTypes.includes('friend_online');
    }
    /**
     * Checks that the user is online
     */
    get isOffline() {
        return this.subTypes.includes('friend_offline');
    }
    /**
     * Checks that the user is invisible
     */
    get isInvisible() {
        return this.subTypes.includes('friend_invisible')
            ? Boolean(this.payload.extra)
            : false;
    }
    /**
     * Checks that the user has logged out of the network himself
     */
    get isSelfLeave() {
        return this.isOffline && !this.payload.extra;
    }
    /**
     * Checks that the user logged out a timeout
     */
    get isTimeoutLeave() {
        return this.isOffline && Boolean(this.payload.extra);
    }
    /**
     * Returns the friend id
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the identifier of the application from which the friend was online
     */
    get applicationId() {
        return this.payload.app_id;
    }
    /**
     * Returns the date when this event was created
     */
    get eventAt() {
        return this.payload.date;
    }
    /**
     * Returns the platform from which the user entered
     *
     * - `1` - m.vk.com or other unknown application
     * - `2` - iPhone
     * - `3` - iPad
     * - `4` - Android
     * - `5` - Windows Phone
     * - `6` - Windows
     * - `7` - vk.com or other unknown application
     */
    get platform() {
        const { extra } = this.payload;
        return extra !== -1
            ? extra
            : undefined;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'userId',
            'eventAt',
            'platform',
            'isSelfLeave',
            'isTimeoutLeave',
            'isOnline',
            'isOffline',
            'isInvisible'
        ]);
    }
}

const subTypes = {
    13: 'dialog_messages_delete',
    14: 'dialog_messages_restore'
};
class DialogMessagesContext extends Context {
    constructor(options) {
        const [eventId, peerId, localId] = options.payload;
        super({
            ...options,
            type: 'dialog_messages',
            subTypes: [
                subTypes[eventId]
            ],
            payload: {
                peer_id: peerId,
                local_id: localId
            }
        });
    }
    /**
     * Checks if messages are delete
     */
    get isDelete() {
        return this.subTypes.includes('dialog_messages_delete');
    }
    /**
     * Checks if messages are restored
     */
    get isRestore() {
        return this.subTypes.includes('dialog_messages_restore');
    }
    /**
     * Returns the peer identifier
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the identifier of the local message
     */
    get localId() {
        return this.payload.local_id;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'peerId',
            'localId',
            'isDelete',
            'isRestore'
        ]);
    }
}

class VKPayTransactionContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'vk_pay_transaction',
            subTypes: [
                options.updateType
            ]
        });
    }
    /**
     * Returns the identifier transfer sender
     */
    get fromId() {
        return this.payload.from_id;
    }
    /**
     * Returns the transfer amount in thousandths of a ruble
     */
    get amount() {
        return this.payload.amount;
    }
    /**
     * Returns the description on the translation
     */
    get description() {
        return this.payload.description;
    }
    /**
     * Returns the unixtime transfer time
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'fromId',
            'amount',
            'description',
            'createdAt'
        ]);
    }
}

class DonutSubscriptionContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'donut_subscription',
            subTypes: [
                options.updateType
            ]
        });
    }
    /**
     * Checks if subscription created
     */
    get isCreated() {
        return this.is(['donut_subscription_create']);
    }
    /**
     * Checks if subscription prolonged
     */
    get isProlonged() {
        return this.is(['donut_subscription_prolonged']);
    }
    /**
     * Checks if subscription expired
     */
    get isExpired() {
        return this.is(['donut_subscription_expired']);
    }
    /**
     * Checks if subscription cancelled
     */
    get isCancelled() {
        return this.is(['donut_subscription_cancelled']);
    }
    /**
     * Returns the id of the user who interacts with the vk donut
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the amount
     */
    get amount() {
        return this.payload.amount;
    }
    /**
     * Returns the amount without fee
     */
    get amountWithoutFee() {
        return this.payload.amount_without_fee;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'isCreated',
            'isProlonged',
            'isExpired',
            'isCancelled',
            'userId',
            'amount',
            'amountWithoutFee'
        ]);
    }
}

class MessageSubscriptionContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'message_subscription',
            subTypes: [
                options.updateType
            ]
        });
    }
    /**
     * Checks that the user has subscribed to messages
     */
    get isSubscribed() {
        return this.subTypes.includes('message_allow');
    }
    /**
     * Checks that the user has unsubscribed from the messages
     */
    get isUnsubscribed() {
        return this.subTypes.includes('message_deny');
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the key
     */
    get key() {
        return this.payload.key;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'userId',
            'key',
            'isSubscribed',
            'isUnsubscribed'
        ]);
    }
}

class DialogNotificationSettingsContext extends Context {
    constructor(options) {
        const [, payload] = options.payload;
        const { disabled_until } = payload;
        super({
            ...options,
            type: 'dialog_notification_settings',
            subTypes: [
                disabled_until === 0
                    ? 'dialog_notification_settings_subscribe'
                    : 'dialog_notification_settings_unsubscribe'
            ],
            payload: payload
        });
    }
    /**
     * Returns the peer identifier
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns time until that notifications are disabled in seconds
     */
    get disabledUntil() {
        return this.payload.disabled_until;
    }
    /**
     * Checks that the notifications have sound
     */
    get hasSound() {
        return Boolean(this.payload.sound);
    }
    /**
     * Checks that the user has subscribed to dialog
     */
    get isSubscribed() {
        return this.subTypes.includes('dialog_notification_settings_subscribe');
    }
    /**
     * Checks that the user has unsubscribed to dialog
     */
    get isUnsubscribed() {
        return this.subTypes.includes('dialog_notification_settings_unsubscribe');
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'peerId',
            'hasSound',
            'disabledUntil',
            'isSubscribed',
            'isUnsubscribed'
        ]);
    }
}

class DonutSubscriptionPriceContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'donut_subscription_price',
            subTypes: [
                options.updateType
            ]
        });
    }
    /**
     * Checks if subscription changed
     */
    get isChanged() {
        return this.is(['donut_subscription_price_changed']);
    }
    /**
     * Returns the id of the user who interacts with the vk donut
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the old amount
     */
    get oldAmount() {
        return this.payload.amount_old;
    }
    /**
     * Returns the new amount
     */
    get newAmount() {
        return this.payload.amount_new;
    }
    /**
     * Returns the diff amount
     */
    get diffAmount() {
        return this.payload.amount_diff;
    }
    /**
     * Returns the diff amount without fee
     */
    get diffAmountWithoutFee() {
        return this.payload.amount_diff_without_fee;
    }
    /**
     * Returns the custom data
     */
    [kSerializeData]() {
        return pickProperties(this, [
            'isChanged',
            'userId',
            'oldAmount',
            'newAmount',
            'diffAmount',
            'diffAmountWithoutFee'
        ]);
    }
}

/**
 * Primary colors used in the text button
 */
exports.ButtonColor = void 0;
(function (ButtonColor) {
    /**
     * The white button, indicates secondary action
     *
     * Hex color #FFFFFF
     */
    ButtonColor["SECONDARY"] = "secondary";
    /**
     * The blue button, indicates the main action
     *
     * Hex color #5181B8
     */
    ButtonColor["PRIMARY"] = "primary";
    /**
     * The red button, indicates a dangerous or a negative action (reject, delete, etc...)
     *
     * Hex color #E64646
     */
    ButtonColor["NEGATIVE"] = "negative";
    /**
     * The green button, indicates a agree, confirm, ...etc
     *
     * Hex color #4BB34B
     */
    ButtonColor["POSITIVE"] = "positive";
})(exports.ButtonColor || (exports.ButtonColor = {}));

const serializePayload = (rawPayload) => {
    const payload = JSON.stringify(rawPayload);
    if (payload.length > 255) {
        throw new RangeError('Maximum length of payload 255 characters');
    }
    return payload;
};
class KeyboardBuilder {
    constructor() {
        /**
         * Does the keyboard close after pressing the button
         */
        this.isOneTime = false;
        /**
         * The keyboard must be attached to the message
         */
        this.isInline = false;
        /**
         * Rows with all buttons
         */
        this.rows = [];
        /**
         * Current row of buttons
         */
        this.currentRow = [];
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Text button, can be colored
     *
     * ```ts
     * builder.textButton({
     *  label: 'Buy a coffee',
     *  payload: {
     *   command: 'buy',
     *   item: 'coffee'
     *  },
     *  color: Keyboard.POSITIVE_COLOR
     * });
     * ```
     */
    textButton({ label, payload: rawPayload = {}, color = exports.ButtonColor.SECONDARY }) {
        if (label.length > 40) {
            throw new RangeError('Maximum length of label 40 characters');
        }
        const payload = serializePayload(rawPayload);
        return this.addButton({
            color,
            action: {
                label,
                payload,
                type: 'text'
            }
        });
    }
    /**
     * URL button
     *
     * ```ts
     * builder.urlButton({
     *  label: 'Buy a coffee',
     *  url: 'https://coffee.mania/buy'
     * });
     * ```
     */
    urlButton({ label, url, payload: rawPayload = {} }) {
        if (label.length > 40) {
            throw new RangeError('Maximum length of label 40 characters');
        }
        const payload = serializePayload(rawPayload);
        return this.addWideButton({
            action: {
                label,
                payload,
                link: url,
                type: 'open_link'
            }
        });
    }
    /**
     * User location request button, occupies the entire keyboard width
     *
     * ```ts
     * builder.locationRequestButton({
     *  payload: {
     *   command: 'order_delivery'
     *  }
     * })
     * ```
     */
    locationRequestButton({ payload: rawPayload = {} }) {
        const payload = serializePayload(rawPayload);
        return this.addWideButton({
            action: {
                payload,
                type: 'location'
            }
        });
    }
    /**
     * VK Pay button, occupies the entire keyboard width
     *
     * ```ts
     * builder.payButton({
     *  hash: {
     *   action: 'transfer-to-group',
     *   group_id: 1,
     *   aid: 10
     *  }
     * })
     * ```
     */
    payButton({ payload: rawPayload, hash: rawHash }) {
        const payload = serializePayload(rawPayload);
        const hash = typeof rawHash === 'object'
            ? String(new url.URLSearchParams(Object.entries(rawHash)))
            : rawHash;
        return this.addWideButton({
            action: {
                payload,
                hash,
                type: 'vkpay'
            }
        });
    }
    /**
     * VK Apps button, occupies the entire keyboard width
     *
     * ```ts
     * builder.applicationButton({
     *  label: 'LiveWidget',
     *  appId: 6232540,
     *  ownerId: -157525928
     * })
     * ```
     */
    applicationButton({ label, appId, ownerId, hash }) {
        if (label.length > 40) {
            throw new RangeError('Maximum length of label 40 characters');
        }
        return this.addWideButton({
            action: {
                label,
                hash,
                app_id: appId,
                owner_id: ownerId,
                type: 'open_app'
            }
        });
    }
    /**
     * Allows without sending a message from the user
     * to receive a notification of a button click and perform the necessary action
     *
     * ```ts
     * builder.callbackButton({
     *  label: 'Buy a coffee',
     *  payload: {
     *   command: 'buy',
     *   item: 'coffee'
     *  }
     * });
     * ```
     */
    callbackButton({ label, payload: rawPayload = {}, color = exports.ButtonColor.SECONDARY }) {
        if (label.length > 40) {
            throw new RangeError('Maximum length of label 40 characters');
        }
        const payload = serializePayload(rawPayload);
        return this.addButton({
            color,
            action: {
                label,
                payload,
                type: 'callback'
            }
        });
    }
    /**
     * Saves the current row of buttons in the general rows
     */
    row() {
        if (this.currentRow.length === 0) {
            return this;
        }
        if (this.currentRow.length > 5) {
            throw new RangeError('Max count of buttons at columns 5');
        }
        this.rows.push(this.currentRow);
        this.currentRow = [];
        return this;
    }
    /**
     * Sets the keyboard to close after pressing
     *
     * ```ts
     *  builder.oneTime();
     *
     *  builder.oneTime(false);
     * ```
     */
    oneTime(enabled = true) {
        this.isOneTime = enabled;
        return this;
    }
    /**
     * Sets the keyboard inline
     *
     * ```ts
     *  builder.inline();
     *
     *  builder.inline(false);
     * ```
     */
    inline(enabled = true) {
        this.isInline = enabled;
        return this;
    }
    /**
     * Clones the builder with all the settings
     */
    clone() {
        const builder = new KeyboardBuilder();
        builder.oneTime(this.isOneTime);
        builder.inline(this.isInline);
        builder.rows = [...this.rows];
        builder.currentRow = [...this.currentRow];
        return builder;
    }
    /**
     * Returns a string to keyboard a VK
     */
    toString() {
        const maxRowsLength = this.isInline
            ? 6
            : 10;
        if (this.rows.length > maxRowsLength) {
            throw new RangeError(`Max count of keyboard rows ${maxRowsLength}`);
        }
        const buttons = this.currentRow.length !== 0
            ? [...this.rows, this.currentRow]
            : this.rows;
        return JSON.stringify(this.isInline
            ? {
                buttons,
                inline: true
            }
            : {
                buttons,
                one_time: this.isOneTime
            });
    }
    /**
     * Adds a button to the current row
     */
    addButton(button) {
        this.currentRow.push(button);
        return this;
    }
    /**
     * Adds a wide button to the new row
     */
    addWideButton(button) {
        if (this.currentRow.length >= 2) {
            this.row();
        }
        this.addButton(button);
        if (this.currentRow.length === 2) {
            this.row();
        }
        return this;
    }
}

class Keyboard {
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * The white button, indicates secondary action
     *
     * Hex color #FFFFFF
     */
    // eslint-disable-next-line class-methods-use-this
    static get SECONDARY_COLOR() {
        return exports.ButtonColor.SECONDARY;
    }
    /**
     * The blue button, indicates the main action
     *
     * Hex color #5181B8
     */
    // eslint-disable-next-line class-methods-use-this
    static get PRIMARY_COLOR() {
        return exports.ButtonColor.PRIMARY;
    }
    /**
     * The red button, indicates a dangerous or a negative action (reject, delete, etc...)
     *
     * Hex color #E64646
     */
    // eslint-disable-next-line class-methods-use-this
    static get NEGATIVE_COLOR() {
        return exports.ButtonColor.NEGATIVE;
    }
    /**
     * The green button, indicates a agree, confirm, ...etc
     *
     * Hex color #4BB34B
     */
    // eslint-disable-next-line class-methods-use-this
    static get POSITIVE_COLOR() {
        return exports.ButtonColor.POSITIVE;
    }
    /**
     * Returns keyboard builder
     */
    static builder() {
        return new KeyboardBuilder();
    }
    /**
     * Assembles a builder of buttons
     */
    static keyboard(rows) {
        const builder = new KeyboardBuilder();
        for (const row of rows) {
            const buttons = Array.isArray(row)
                ? row
                : [row];
            for (const { kind, options } of buttons) {
                if (kind === 'text') {
                    builder.textButton(options);
                    continue;
                }
                if (kind === 'url') {
                    builder.urlButton(options);
                    continue;
                }
                if (kind === 'location_request') {
                    builder.locationRequestButton(options);
                    continue;
                }
                if (kind === 'vk_pay') {
                    builder.payButton(options);
                    continue;
                }
                if (kind === 'vk_application') {
                    builder.applicationButton(options);
                    continue;
                }
                if (kind === 'callback') {
                    builder.callbackButton(options);
                    continue;
                }
                throw new TypeError('Unsupported type button');
            }
            builder.row();
        }
        return builder;
    }
    /**
     * Text button, can be colored
     */
    static textButton(options) {
        return { options, kind: 'text' };
    }
    /**
     * URL button
     */
    static urlButton(options) {
        return { options, kind: 'url' };
    }
    /**
     * User location request button, occupies the entire keyboard width
     */
    static locationRequestButton(options) {
        return { options, kind: 'location_request' };
    }
    /**
     * VK Pay button, occupies the entire keyboard width
     */
    static payButton(options) {
        return { options, kind: 'vk_pay' };
    }
    /**
     * VK Apps button, occupies the entire keyboard width
     */
    static applicationButton(options) {
        return { options, kind: 'vk_application' };
    }
    /**
     * Allows without sending a message from the user
     * to receive a notification of a button click and perform the necessary action
     */
    static callbackButton(options) {
        return { options, kind: 'callback' };
    }
}

// eslint-disable-next-line import/extensions
const { stat: fileStat } = fs.promises;
const { MISSING_PARAMETERS, NO_FILES_TO_UPLOAD, EXCEEDED_MAX_FILES, UNSUPPORTED_SOURCE_TYPE } = exports.UploadErrorCode;
const isURL = /^https?:\/\//i;
const DocumentTypes = {
    doc: DocumentAttachment,
    graffiti: GraffitiAttachment,
    audio_message: AudioMessageAttachment
};
class Upload {
    /**
     * Constructor
     */
    constructor({ api, ...options }) {
        this.api = api;
        this.options = {
            // 20 ms
            agent: https.globalAgent,
            uploadTimeout: 20000,
            ...options
        };
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Uploading photos to an album
     */
    async photoAlbum(params) {
        const photos = await this.conduct({
            field: 'file',
            params,
            getServer: this.api.photos.getUploadServer,
            serverParams: ['album_id', 'group_id'],
            saveFiles: this.api.photos.save,
            saveParams: ['album_id', 'group_id', 'latitude', 'longitude', 'caption'],
            maxFiles: 5,
            attachmentType: 'photo'
        });
        return photos.map(photo => (new PhotoAttachment({
            api: this.api,
            payload: photo
        })));
    }
    /**
     * Uploading photos to the wall
     */
    async wallPhoto(params) {
        const [photo] = await this.conduct({
            field: 'photo',
            params,
            getServer: this.api.photos.getWallUploadServer,
            serverParams: ['group_id'],
            saveFiles: this.api.photos.saveWallPhoto,
            saveParams: ['user_id', 'group_id', 'latitude', 'longitude', 'caption'],
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new PhotoAttachment({
            api: this.api,
            payload: photo
        });
    }
    /**
     * Uploading the main photo of a user or community
     */
    ownerPhoto(params) {
        return this.conduct({
            field: 'photo',
            params,
            getServer: this.api.photos.getOwnerPhotoUploadServer,
            serverParams: ['owner_id'],
            saveFiles: this.api.photos.saveOwnerPhoto,
            maxFiles: 1,
            attachmentType: 'photo'
        });
        // {
        //   photo_hash: 'c8d43da5e1281b7aed6bb8f0c4f3ad69',
        //   photo_src: 'https://pp.userapi.com/c836429/v836429114/673f6/5VJB8GXtK88.jpg',
        //   photo_src_big: 'https://pp.userapi.com/c836429/v836429114/673f7/7fGvrJ1wOx0.jpg',
        //   photo_src_small: 'https://pp.userapi.com/c836429/v836429114/673f5/l5d1ASgyuxk.jpg',
        //   saved: 1,
        //   post_id: 3331
        // }
    }
    /**
     * Uploading a photo to a private message
     */
    async messagePhoto(params) {
        const [photo] = await this.conduct({
            field: 'photo',
            params,
            getServer: this.api.photos.getMessagesUploadServer,
            serverParams: ['peer_id'],
            saveFiles: this.api.photos.saveMessagesPhoto,
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new PhotoAttachment({
            api: this.api,
            payload: photo
        });
    }
    /**
     * Uploading the main photo for a chat
     */
    chatPhoto(params) {
        return this.conduct({
            field: 'file',
            params,
            getServer: this.api.photos.getChatUploadServer,
            serverParams: ['chat_id', 'crop_x', 'crop_y', 'crop_width'],
            saveFiles: file => (this.api.messages.setChatPhoto({ file })),
            maxFiles: 1,
            attachmentType: 'photo'
        });
        // {
        //   message_id: 3745390,
        //   chat: {
        //    id: 152,
        //    type: 'chat',
        //    title: '<Titile name>',
        //    admin_id: 335447860,
        //    users: [335447860,
        //      140192020,
        //      153711615,
        //      314650825,
        //      218747758,
        //      155944103,
        //      159737827,
        //      64299368,
        //      157534541,
        //      153608064,
        //      335540121,
        //      349609849,
        //      344184938,
        //      341178526,
        //      198210835,
        //      135446999,
        //      163850606,
        //      123640861,
        //      316216798,
        //      359118107,
        //      241235369,
        //      160213445,
        //      126624591,
        //      390221395,
        //      195624402,
        //      94955334,
        //      167302501,
        //      17516523,
        //      294583792,
        //      294869767,
        //      114281676,
        //      137762280,
        //      406076540,
        //      410605840,
        //      395646590,
        //      421554042,
        //      331599090,
        //      342269712
        //    ],
        //    photo_50: 'https://pp.userapi.com/c837624/v837624114/5d495/gLgv-JrVmkk.jpg',
        //    photo_100: 'https://pp.userapi.com/c837624/v837624114/5d494/VNp61I1yuCk.jpg',
        //    photo_200: 'https://pp.userapi.com/c837624/v837624114/5d492/lAoc_fAai2Q.jpg'
        //   }
        // }
    }
    /**
     * Uploading a photo for a product
     */
    async marketPhoto(params) {
        const [photo] = await this.conduct({
            field: 'file',
            params,
            getServer: this.api.photos.getMarketUploadServer,
            serverParams: ['group_id', 'main_photo', 'crop_x', 'crop_y', 'crop_width'],
            saveFiles: this.api.photos.saveMarketPhoto,
            saveParams: ['group_id'],
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new PhotoAttachment({
            api: this.api,
            payload: photo
        });
    }
    /**
     * Uploads a photo for the selection of goods
     */
    async marketAlbumPhoto(params) {
        const [photo] = await this.conduct({
            field: 'file',
            params,
            getServer: this.api.photos.getMarketAlbumUploadServer,
            serverParams: ['group_id'],
            saveFiles: this.api.photos.saveMarketAlbumPhoto,
            saveParams: ['group_id'],
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new PhotoAttachment({
            api: this.api,
            payload: photo
        });
    }
    /**
     * Uploads audio
     */
    async audio(params) {
        const audio = await this.conduct({
            field: 'file',
            params,
            // @ts-expect-error
            getServer: this.api.audio.getUploadServer,
            // @ts-expect-error
            saveFiles: this.api.audio.save,
            saveParams: ['title', 'artist'],
            maxFiles: 1,
            attachmentType: 'audio'
        });
        return new AudioAttachment({
            api: this.api,
            payload: audio
        });
    }
    /**
     * Uploads video
     */
    async video(params) {
        const save = await this.api.video.save(pickExistingProperties(params, [
            'group_id',
            'album_id',
            'link',
            'name',
            'description',
            'is_private',
            'wallpost',
            'privacy_view',
            'privacy_comment',
            'no_comments',
            'repeat',
            'compression'
        ]));
        save.id = save.video_id;
        if (params.link !== undefined) {
            const response = await fetch(save.upload_url, {
                agent: this.options.agent
            });
            await response.json();
            return new VideoAttachment({
                api: this.api,
                payload: save
            });
        }
        const source = normalizeSource(params.source);
        const { formData, knownLength } = await this.buildPayload({
            maxFiles: 1,
            field: 'video_file',
            attachmentType: 'video',
            values: source.values
        });
        const video = await this.upload(save.upload_url, {
            formData,
            timeout: source.timeout,
            forceBuffer: !knownLength
        });
        return new VideoAttachment({
            api: this.api,
            payload: { ...save, ...video }
        });
    }
    /**
     * Uploads document
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async conductDocument(params, { attachmentType = 'doc' } = {}) {
        const response = await this.conduct({
            field: 'file',
            params,
            getServer: this.api.docs.getUploadServer,
            serverParams: ['type', 'group_id'],
            saveFiles: this.api.docs.save,
            saveParams: ['title', 'tags'],
            maxFiles: 1,
            attachmentType
        });
        const ConductAttachment = DocumentTypes[response.type] || DocumentTypes.doc;
        return new ConductAttachment({
            api: this.api,
            payload: response[response.type]
        });
    }
    /**
     * Uploads document
     */
    document(params) {
        return this.conductDocument(params, {
            attachmentType: 'doc'
        });
    }
    /**
     * Uploads wall document
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async conductWallDocument(params, { attachmentType = 'doc' } = {}) {
        const response = await this.conduct({
            field: 'file',
            params,
            getServer: this.api.docs.getWallUploadServer,
            serverParams: ['type', 'group_id'],
            saveFiles: this.api.docs.save,
            saveParams: ['title', 'tags'],
            maxFiles: 1,
            attachmentType
        });
        const ConductAttachment = DocumentTypes[response.type] || DocumentTypes.doc;
        return new ConductAttachment({
            api: this.api,
            payload: response[response.type]
        });
    }
    /**
     * Uploads wall document
     */
    wallDocument(params) {
        return this.conductWallDocument(params, {
            attachmentType: 'doc'
        });
    }
    /**
     * Uploads wall document
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async conductMessageDocument(params, { attachmentType = 'doc' } = {}) {
        const response = await this.conduct({
            field: 'file',
            params,
            getServer: this.api.docs.getMessagesUploadServer,
            serverParams: ['type', 'peer_id'],
            saveFiles: this.api.docs.save,
            saveParams: ['title', 'tags'],
            maxFiles: 1,
            attachmentType
        });
        const ConductAttachment = DocumentTypes[response.type] || DocumentTypes.doc;
        return new ConductAttachment({
            api: this.api,
            payload: response[response.type]
        });
    }
    /**
     * Uploads message document
     */
    messageDocument(params) {
        return this.conductMessageDocument({
            ...params,
            type: 'doc'
        }, {
            attachmentType: 'doc'
        });
    }
    /**
     * Uploads audio message
     */
    audioMessage(params) {
        return this.conductMessageDocument({
            ...params,
            type: 'audio_message'
        }, {
            attachmentType: 'audioMessage'
        });
        // { type: 'audio_message',
        // audio_message: {
        //   id: 484017542,
        //   owner_id: 195624402,
        //   duration: 48,
        //   waveform: [...],
        //   link_ogg:
        //   'https://psv4.userapi.com/c805324//u195624402/audiomsg/15734aa6bb.ogg',
        //   link_mp3:
        //   'https://psv4.userapi.com/c805324//u195624402/audiomsg/15734aa6bb.mp3',
        //   access_key: '295cc90411e6222db0' } }
    }
    /**
     * Uploads graffiti in documents
     */
    documentGraffiti(params) {
        return this.conductDocument({
            ...params,
            type: 'graffiti'
        }, {
            attachmentType: 'graffiti'
        });
    }
    /**
     * Uploads graffiti in messages
     */
    messageGraffiti(params) {
        return this.conductMessageDocument({
            ...params,
            type: 'graffiti'
        }, {
            attachmentType: 'graffiti'
        });
    }
    /**
     * Uploads community cover
     */
    groupCover(params) {
        return this.conduct({
            field: 'photo',
            params,
            getServer: this.api.photos.getOwnerCoverPhotoUploadServer,
            serverParams: ['group_id', 'crop_x', 'crop_y', 'crop_x2', 'crop_y2'],
            saveFiles: this.api.photos.saveOwnerCoverPhoto,
            maxFiles: 1,
            attachmentType: 'photo'
        });
        // {
        //  images: [
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46404/r-1Nhr-Dktc.jpg',
        //      width: 200,
        //      height: 50
        //    },
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46403/oDB9tAgtUrQ.jpg',
        //      width: 400,
        //      height: 101
        //    },
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46400/gLwCTmDEPXY.jpg',
        //      width: 795,
        //      height: 200
        //    },
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46402/w2ucyq8zwF8.jpg',
        //      width: 1080,
        //      height: 272
        //    },
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46401/YTmN89yMaU0.jpg',
        //      width: 1590,
        //      height: 400
        //    }
        //  ]
        // }
    }
    /**
     * Uploads photo stories
     */
    async storiesPhoto(params) {
        const { items: [story] } = await this.conduct({
            field: 'file',
            params,
            getServer: this.api.stories.getPhotoUploadServer,
            serverParams: [
                'add_to_news',
                'user_ids',
                'reply_to_story',
                'link_text',
                'link_url',
                'group_id',
                'attach_access_key'
            ],
            saveFiles: file => (this.api.stories.save({
                upload_results: file.upload_result
            })),
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new StoryAttachment({
            api: this.api,
            payload: story
        });
    }
    /**
     * Uploads video stories
     */
    async storiesVideo(params) {
        const { items: [story] } = await this.conduct({
            field: 'video_file',
            params,
            getServer: this.api.stories.getVideoUploadServer,
            serverParams: [
                'add_to_news',
                'user_ids',
                'reply_to_story',
                'link_text',
                'link_url',
                'group_id'
            ],
            saveFiles: file => (this.api.stories.save({
                upload_results: file.upload_result
            })),
            maxFiles: 1,
            attachmentType: 'video'
        });
        return new StoryAttachment({
            api: this.api,
            payload: story
        });
    }
    /**
     * Uploads poll photo
     */
    pollPhoto(params
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
        return this.conduct({
            field: 'file',
            params,
            getServer: this.api.polls.getPhotoUploadServer,
            serverParams: ['owner_id'],
            saveFiles: this.api.polls.savePhoto,
            maxFiles: 1,
            attachmentType: 'photo'
        });
    }
    /**
     * Behavior for the upload method
     */
    async conduct({ field, params, getServer, serverParams = [], saveFiles, saveParams = [], uploadParams = [], maxFiles = 1, attachmentType
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
     }) {
        if (!params || !params.source) {
            throw new UploadError({
                message: 'Missing upload params',
                code: MISSING_PARAMETERS
            });
        }
        const source = normalizeSource(params.source);
        if (source.uploadUrl !== undefined) {
            // eslint-disable-next-line no-param-reassign
            getServer = () => Promise.resolve({
                upload_url: source.uploadUrl
            });
        }
        const { length: valuesLength } = source.values;
        if (valuesLength === 0) {
            throw new UploadError({
                message: 'No files to upload',
                code: NO_FILES_TO_UPLOAD
            });
        }
        if (valuesLength > maxFiles) {
            throw new UploadError({
                message: 'The number of files uploaded has exceeded',
                code: EXCEEDED_MAX_FILES
            });
        }
        const [{ upload_url: url }, { formData, knownLength }] = await Promise.all([
            getServer(pickExistingProperties(params, serverParams)),
            this.buildPayload({
                field,
                values: source.values,
                maxFiles,
                attachmentType
            })
        ]);
        const uploadParamsMap = pickExistingProperties(params, uploadParams);
        for (const [key, value] of Object.entries(uploadParamsMap)) {
            formData.append(key, value);
        }
        const uploaded = await this.upload(url, {
            formData,
            timeout: source.timeout,
            forceBuffer: !knownLength
        });
        if (typeof uploaded !== 'object') {
            const response = await saveFiles(uploaded);
            return response;
        }
        const response = await saveFiles({
            ...pickExistingProperties(params, saveParams),
            ...uploaded
        });
        return response;
    }
    /**
     * Building form data
     */
    // eslint-disable-next-line class-methods-use-this
    async buildPayload({ field, values, maxFiles, attachmentType }) {
        const formData = new formdataNode.FormData();
        const isMultipart = maxFiles > 1;
        let knownLength = true;
        const tasks = values.map(async (media, i) => {
            let { value, filename, contentLength = 0 } = media;
            if (typeof value === 'string') {
                if (isURL.test(value)) {
                    const response = await fetch(value);
                    // @ts-expect-error
                    value = response.body;
                    const length = response.headers.get('content-length');
                    if (length !== null) {
                        contentLength = Number(length);
                    }
                }
                else {
                    const stats = await fileStat(value);
                    contentLength = stats.size;
                    value = fs.createReadStream(value);
                }
            }
            if (filename === undefined) {
                filename = `file${i}.${DefaultExtension[attachmentType] || 'dat'}`;
            }
            const isBuffer = Buffer.isBuffer(value);
            if (isStream(value) || isBuffer) {
                const name = isMultipart
                    ? field + (i + 1)
                    : field;
                const { contentType } = media;
                const fileContentType = contentType
                    || DefaultContentType[attachmentType];
                const file = isBuffer
                    ? new formdataNode.File([value], filename, {
                        type: fileContentType
                    })
                    // Workground for NodeJS streams: https://github.com/octet-stream/form-data/issues/32
                    : {
                        size: Number(contentLength),
                        type: fileContentType,
                        stream: () => (value),
                        [Symbol.toStringTag]: 'Blob'
                    };
                if (!contentLength) {
                    knownLength = false;
                }
                formData.append(name, file, filename);
                return;
            }
            throw new UploadError({
                message: 'Unsupported source type',
                code: UNSUPPORTED_SOURCE_TYPE
            });
        });
        await Promise.all(tasks);
        return {
            formData,
            knownLength
        };
    }
    /**
     * Upload form data
     */
    async upload(url, { formData, timeout, forceBuffer }) {
        const { agent, uploadTimeout } = this.options;
        const encoder = new formDataEncoder.FormDataEncoder(formData);
        const rawBody = stream.Readable.from(encoder.encode());
        const controller = new abortController.AbortController();
        const interval = setTimeout(() => controller.abort(), timeout || uploadTimeout);
        const headers = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Connection: 'keep-alive',
            // eslint-disable-next-line @typescript-eslint/naming-convention
            ...encoder.headers
        };
        const body = forceBuffer
            ? await streamToBuffer(rawBody)
            : rawBody;
        if (forceBuffer) {
            headers['Content-Length'] = String(body.length);
        }
        try {
            const response = await fetch(url, {
                agent,
                compress: false,
                method: 'POST',
                signal: controller.signal,
                headers,
                body
            });
            if (!response.ok) {
                throw new Error(response.statusText);
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const result = await response.json();
            return result.response !== undefined
                ? result.response
                : result;
        }
        finally {
            clearTimeout(interval);
        }
    }
}
inspectable.inspectable(Upload);

const executeRequests = async (api, queue) => {
    const out = {
        response: [],
        errors: []
    };
    if (queue.length === 0) {
        return out;
    }
    while (queue.length > 0) {
        const tasks = queue.splice(0, 25);
        const code = getChainReturn(tasks.map(String));
        try {
            const response = await api.execute({ code });
            resolveExecuteTask(tasks, response);
            out.response.push(...response.response);
            out.errors.push(...response.errors);
        }
        catch (error) {
            for (const task of tasks) {
                task.reject(error);
            }
            throw error;
        }
    }
    return out;
};
const executes = ({ api, method, queue }) => (executeRequests(api, queue.map(params => (new APIRequest({
    api,
    method,
    params
})))));

class Chain {
    /**
     * Constructor
     */
    constructor({ api }) {
        this.started = false;
        this.queue = [];
        this.api = api;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Adds method to queue
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    append(method, params) {
        if (this.started) {
            return Promise.reject(new VKError({
                message: 'Chain already started',
                code: 'ALREADY_STARTED'
            }));
        }
        const request = new APIRequest({
            api: this.api,
            method,
            params
        });
        this.queue.push(request);
        return request.promise;
    }
    /**
     * Promise based
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    then(thenFn, catchFn) {
        // @ts-expect-error
        return this.run().then(thenFn, catchFn);
    }
    /**
     * Starts the chain
     */
    async run() {
        if (this.started) {
            throw new VKError({
                message: 'Chain already started',
                code: 'ALREADY_STARTED'
            });
        }
        this.started = true;
        return executeRequests(this.api, this.queue);
    }
}
inspectable.inspectable(Chain, {
    // @ts-expect-error
    serialize: ({ started, queue }) => ({
        started,
        queue
    })
});

const getExecuteCode = ({ method, params }) => (`
		var params = ${getExecuteParams(params)};

		params.offset = parseInt(Args.offset);

		var total = parseInt(Args.total);
		var received = parseInt(Args.received);

		var parallelRequests = parseInt(Args.parallelRequests);

		var proceed = total == 0 || received < total;

		var i = 0, items = [], profiles = [], groups = [], result, length;

		while (i < parallelRequests && proceed) {
			result = API.${method}(params);
			length = result.items.length;

			if (total == 0 || total > result.count) {
				total = result.count;
			}

			items = items + result.items;
			if (result.profiles)
				profiles = profiles + result.profiles;
			if (result.groups)
				groups = groups + result.groups;

			received = received + length;
			params.offset = params.offset + length;

			proceed = received < total;
			i = i + 1;
		}

		return {
			count: total,
			items: items.splice(0, total),
			profiles: profiles.splice(0, total),
			groups: groups.splice(0, total)
		};
	`);

const debug$3 = createDebug('api-io:collect');
async function* createCollectIterator({ api, method, params: rawParams = {}, countPerRequest, maxCount = Infinity, retryLimit = 3, parallelRequests = 25 }) {
    var _a, _b;
    if (parallelRequests < 1 || parallelRequests > 25) {
        throw new RangeError('The number of parallel calls can be between 1 and 25');
    }
    const params = {
        ...rawParams,
        count: countPerRequest
    };
    const code = getExecuteCode({ method, params });
    const { count: desiredCount = Infinity, offset: ignoredOffset = 0 } = rawParams;
    let total = Math.min(maxCount, desiredCount);
    if (!Number.isFinite(total)) {
        total = undefined;
    }
    let offset = ignoredOffset;
    let received = 0;
    let retries = 0;
    let supportExecute = true;
    while (true) {
        const firstTime = received === 0;
        if (!firstTime && total <= received) {
            break;
        }
        const singleRequests = !supportExecute || parallelRequests === 1;
        let result;
        try {
            if (singleRequests) {
                result = await api.call(method, {
                    ...params,
                    offset
                });
            }
            else {
                const { errors, response } = await api.execute({
                    code,
                    total,
                    offset,
                    received,
                    parallelRequests
                });
                if (errors.length !== 0) {
                    throw new CollectError({
                        message: 'Execute error',
                        code: exports.CollectErrorCode.EXECUTE_ERROR,
                        errors
                    });
                }
                result = response;
            }
            retries = 0;
        }
        catch (error) {
            if (error instanceof CollectError) {
                throw error;
            }
            if (retries === retryLimit) {
                throw error;
            }
            retries += 1;
            if (error.code === exports.APIErrorCode.APP_AUTH) {
                supportExecute = false;
                debug$3('execute not supported in token');
                continue;
            }
            if (error.code === exports.APIErrorCode.RUNTIME) {
                // eslint-disable-next-line no-param-reassign
                parallelRequests -= 1;
                continue;
            }
            continue;
        }
        if (total === undefined || total > result.count) {
            total = result.count;
        }
        const { length } = result.items;
        if (length === 0) {
            break;
        }
        offset += length;
        received += length;
        const percent = Math.floor((received / total) * 100);
        yield {
            received,
            percent,
            total,
            items: result.items,
            profiles: (_a = result.profiles) !== null && _a !== void 0 ? _a : [],
            groups: (_b = result.groups) !== null && _b !== void 0 ? _b : []
        };
    }
}

const { NEED_RESTART, POLLING_REQUEST_FAILED } = exports.UpdatesErrorCode;
const debug$2 = createDebug('vk-io:updates');
/**
 * Version polling
 */
const POLLING_VERSION = 10;
class PollingTransport {
    constructor({ api, ...options }) {
        this.started = false;
        /**
         * 2 -  Attachments
         * 8 -  Extended events
         * 64 - Online user platform ID
         * 128 - Return random_id
         */
        // eslint-disable-next-line no-bitwise
        this.mode = 2 | 8 | 64 | 128;
        this.ts = 0;
        this.pts = 0;
        this.restarted = 0;
        this.api = api;
        this.options = options;
    }
    async start() {
        if (this.started) {
            throw new Error('Polling updates already started');
        }
        if (!this.pollingHandler) {
            throw new Error('You didn\'t subscribe to updates');
        }
        this.started = true;
        try {
            const { pollingGroupId } = this.options;
            const isGroup = pollingGroupId !== undefined;
            const { server, key, ts } = isGroup
                ? await this.api.groups.getLongPollServer({
                    group_id: pollingGroupId
                })
                : await this.api.messages.getLongPollServer({
                    lp_version: POLLING_VERSION
                });
            if (this.ts === 0) {
                this.ts = ts;
            }
            const pollingURL = isGroup
                ? server
                : `https://${server}`;
            this.url = new url.URL(pollingURL);
            this.url.search = String(new url.URLSearchParams({
                key,
                act: 'a_check',
                wait: '25',
                mode: String(this.mode),
                version: String(POLLING_VERSION)
            }));
            this.startFetchLoop();
            debug$2(`${isGroup ? 'Bot' : 'User'} Polling started`);
        }
        catch (error) {
            this.started = false;
            throw error;
        }
    }
    /**
     * Stopping gets updates
     */
    async stop() {
        this.started = false;
        this.restarted = 0;
    }
    /**
     * Starts forever fetch updates  loop
     */
    async startFetchLoop() {
        try {
            while (this.started) {
                await this.fetchUpdates();
            }
        }
        catch (error) {
            debug$2('longpoll error', error);
            const { pollingWait, pollingRetryLimit } = this.options;
            if (error.code !== NEED_RESTART && this.restarted !== pollingRetryLimit) {
                this.restarted += 1;
                debug$2('longpoll restart request');
                await delay(3e3);
                this.startFetchLoop();
                return;
            }
            while (this.started) {
                try {
                    await this.stop();
                    await this.start();
                    break;
                }
                catch (restartError) {
                    debug$2('longpoll restarted error', restartError);
                    this.started = true;
                    await delay(pollingWait);
                }
            }
        }
    }
    /**
     * Gets updates
     */
    async fetchUpdates() {
        this.url.searchParams.set('ts', String(this.ts));
        debug$2('http -->');
        const controller = new abortController.AbortController();
        const interval = setTimeout(() => controller.abort(), 30e3);
        let result;
        try {
            const response = await fetch(this.url, {
                agent: this.options.agent,
                method: 'GET',
                compress: false,
                signal: controller.signal,
                headers: {
                    connection: 'keep-alive'
                }
            });
            debug$2(`http <-- ${response.status}`);
            if (!response.ok) {
                throw new UpdatesError({
                    code: POLLING_REQUEST_FAILED,
                    message: 'Polling request failed'
                });
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            result = await response.json();
        }
        finally {
            clearTimeout(interval);
        }
        if (result.failed !== undefined) {
            if (result.failed === 1) {
                this.ts = result.ts;
                return;
            }
            this.ts = 0;
            throw new UpdatesError({
                code: NEED_RESTART,
                message: 'The server has failed'
            });
        }
        this.restarted = 0;
        this.ts = result.ts;
        if (result.pts) {
            this.pts = Number(result.pts);
        }
        /* Async handle updates */
        for (const update of result.updates) {
            this.pollingHandler(update);
        }
    }
    subscribe(handler) {
        this.pollingHandler = handler;
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const parseRequestJSON = async (req) => {
    const chunks = [];
    let totalSize = 0;
    for await (const chunk of req) {
        totalSize += chunk.length;
        chunks.push(chunk);
    }
    return JSON.parse(Buffer.concat(chunks, totalSize).toString('utf8'));
};

const debug$1 = createDebug('vk-io:updates');
const defaultNextHandler = (req, res) => {
    res.writeHead(403);
    res.end();
};
class WebhookTransport {
    constructor({ api, ...options }) {
        this.started = false;
        this.api = api;
        this.options = options;
    }
    /**
     * Starts the webhook server
     */
    async start({ path = '/', tls, host, port: customPort, next = defaultNextHandler } = {}) {
        if (this.started) {
            throw new Error('Webhook updates already started');
        }
        if (!this.webhookHandler) {
            throw new Error('You didn\'t subscribe to updates');
        }
        this.started = true;
        try {
            const webhookCallback = this.getWebhookCallback(path);
            const callback = (req, res) => (webhookCallback(req, res, () => (next(req, res))));
            this.webhookServer = tls
                ? https.createServer(tls, callback)
                : http.createServer(callback);
            const { webhookServer } = this;
            const port = customPort || (tls
                ? 443
                : 80);
            await util.promisify(webhookServer.listen)
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#unmatched-parameters-are-no-longer-related
                .call(webhookServer, { host, port });
            debug$1(`Webhook listening on port: ${port}`);
        }
        catch (error) {
            this.started = false;
            throw error;
        }
    }
    /**
     * Stopping gets updates
     */
    async stop() {
        this.started = false;
        if (this.webhookServer !== undefined) {
            const { webhookServer } = this;
            await util.promisify(webhookServer.close).call(webhookServer);
            this.webhookServer = undefined;
        }
    }
    /**
     * Returns webhook callback like http[s] or express
     */
    getWebhookCallback(path) {
        const headers = {
            connection: 'keep-alive',
            'content-type': 'text/plain'
        };
        const checkIsNotValidPath = path !== undefined
            ? (requestPath) => requestPath !== path
            : () => false;
        return async (req, res, next) => {
            if (req.method !== 'POST' || checkIsNotValidPath(req.url)) {
                next === null || next === void 0 ? void 0 : next();
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const reqBody = req.body;
            let update;
            try {
                update = typeof reqBody !== 'object'
                    ? await parseRequestJSON(req)
                    : reqBody;
            }
            catch (e) {
                debug$1(e);
                return;
            }
            try {
                const { webhookSecret, webhookConfirmation } = this.options;
                if (webhookSecret !== undefined && update.secret !== webhookSecret) {
                    res.writeHead(403);
                    res.end();
                    return;
                }
                if (update.type === 'confirmation') {
                    if (webhookConfirmation === undefined) {
                        res.writeHead(500);
                        res.end();
                        return;
                    }
                    res.writeHead(200, headers);
                    res.end(String(webhookConfirmation));
                    return;
                }
                res.writeHead(200, headers);
                res.end('ok');
                this.webhookHandler(update).catch((error) => {
                    // eslint-disable-next-line no-console
                    console.error('Handle webhook update error', error);
                });
            }
            catch (error) {
                debug$1('webhook error', error);
                res.writeHead(415);
                res.end();
            }
        };
    }
    subscribe(handler) {
        this.webhookHandler = handler;
    }
    /**
     * Returns the middleware for the webhook under koa
     */
    getKoaWebhookMiddleware() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return async (context) => {
            const update = context.request.body;
            const { webhookSecret, webhookConfirmation } = this.options;
            if (webhookSecret !== undefined && update.secret !== webhookSecret) {
                context.status = 403;
                return;
            }
            if (update.type === 'confirmation') {
                if (webhookConfirmation === undefined) {
                    context.status = 500;
                    return;
                }
                context.body = webhookConfirmation;
                return;
            }
            context.body = 'ok';
            context.set('connection', 'keep-alive');
            /* Do not delay server response */
            setImmediate(() => this.webhookHandler(update));
        };
    }
}

const debug = createDebug('vk-io:updates');
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const webhookContextsEvents = [
    [
        ['message_new', 'message_edit', 'message_reply'],
        MessageContext
    ],
    [
        ['message_allow', 'message_deny'],
        MessageSubscriptionContext
    ],
    [
        ['message_event'],
        MessageEventContext
    ],
    [
        ['photo_new', 'audio_new', 'video_new'],
        NewAttachmentsContext
    ],
    [
        ['wall_post_new', 'wall_repost'],
        WallPostContext
    ],
    [
        ['group_join', 'group_leave'],
        GroupMemberContext
    ],
    [
        ['user_block', 'user_unblock'],
        GroupUserContext
    ],
    [
        [
            'photo_comment_new',
            'photo_comment_edit',
            'photo_comment_delete',
            'photo_comment_restore',
            'video_comment_new',
            'video_comment_edit',
            'video_comment_delete',
            'video_comment_restore',
            'wall_reply_new',
            'wall_reply_edit',
            'wall_reply_delete',
            'wall_reply_restore',
            'board_post_new',
            'board_post_edit',
            'board_post_delete',
            'board_post_restore',
            'market_comment_new',
            'market_comment_edit',
            'market_comment_delete',
            'market_comment_restore'
        ],
        CommentContext
    ],
    [
        ['poll_vote_new'],
        VoteContext
    ],
    [
        ['group_change_photo', 'group_officers_edit', 'group_change_settings'],
        GroupUpdateContext
    ],
    [
        ['message_typing_state'],
        TypingContext
    ],
    [
        ['app_payload'],
        VKAppPayloadContext
    ],
    [
        ['vkpay_transaction'],
        VKPayTransactionContext
    ],
    [
        ['like_add', 'like_remove'],
        LikeContext
    ],
    [
        ['market_order_new', 'market_order_edit'],
        MarketOrderContext
    ],
    [
        [
            'donut_subscription_create',
            'donut_subscription_prolonged',
            'donut_subscription_expired',
            'donut_subscription_cancelled'
        ],
        DonutSubscriptionContext
    ],
    [
        ['donut_subscription_price_changed'],
        DonutSubscriptionPriceContext
    ],
    [
        [
            'donut_money_withdraw',
            'donut_money_withdraw_error'
        ],
        DonutWithdrawContext
    ]
];
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const pollingContextsEvents = [
    [
        [1, 2, 3],
        MessageFlagsContext
    ],
    [
        [4, 5, 18],
        MessageContext
    ],
    [
        [6, 7],
        MessagesReadContext
    ],
    [
        [8, 9, 81],
        FriendActivityContext
    ],
    [
        [10, 11, 12],
        DialogFlagsContext
    ],
    [
        [13, 14],
        DialogMessagesContext
    ],
    [
        [63, 64, 65, 66, 67],
        TypingContext
    ],
    [
        [114],
        DialogNotificationSettingsContext
    ]
];
const makeContexts = (groups) => {
    const contexts = {};
    for (const [events, UpdateContext] of groups) {
        for (const event of events) {
            contexts[event] = UpdateContext;
        }
    }
    return contexts;
};
const webhookContexts = makeContexts(webhookContextsEvents);
const pollingContexts = makeContexts(pollingContextsEvents);
class Updates {
    /**
     * Constructor
     */
    constructor({ api, upload, ...options }) {
        this.composer = middlewareIo.Composer.builder()
            .caught((context, error) => {
            // eslint-disable-next-line no-console
            console.error(error);
        });
        this.api = api;
        this.upload = upload;
        this.options = {
            agent: https.globalAgent,
            pollingWait: 3e3,
            pollingRetryLimit: 3,
            pollingGroupId: undefined,
            webhookSecret: undefined,
            webhookConfirmation: undefined,
            ...options
        };
        this.recompose();
        this.pollingTransport = new PollingTransport({
            api,
            ...this.options
        });
        this.webhookTransport = new WebhookTransport({
            api,
            ...this.options
        });
        this.webhookTransport.subscribe(this.handleWebhookUpdate.bind(this));
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Checks is started
     */
    get isStarted() {
        return this.pollingTransport.started || this.webhookTransport.started;
    }
    /**
     * Added middleware
     */
    use(middleware) {
        if (typeof middleware !== 'function') {
            throw new TypeError('Middleware must be a function');
        }
        this.composer.use(middleware);
        this.recompose();
        return this;
    }
    on(rawEvents, rawHandlers) {
        const events = !Array.isArray(rawEvents)
            ? [rawEvents]
            : rawEvents;
        const hasEvents = events.every(Boolean);
        if (!hasEvents) {
            throw new Error('Events should be not empty');
        }
        const handler = Array.isArray(rawHandlers)
            ? middlewareIo.compose(rawHandlers)
            : rawHandlers;
        if (typeof handler !== 'function') {
            throw new TypeError('Handler must be a function');
        }
        return this.use((context, next) => (context.is(events)
            // @ts-expect-error
            ? handler(context, next)
            : next()));
    }
    /**
     * Handles longpoll event
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    handlePollingUpdate(update) {
        debug('longpoll update', update);
        const { 0: type } = update;
        const UpdateContext = pollingContexts[type];
        if (!UpdateContext) {
            debug(`Unsupported polling context type ${type}`);
            return Promise.resolve();
        }
        return this.dispatchMiddleware(new UpdateContext({
            api: this.api,
            upload: this.upload,
            payload: update,
            updateType: type,
            source: exports.UpdateSource.POLLING
        }));
    }
    /**
     * Handles webhook event
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    handleWebhookUpdate(update) {
        debug('webhook update', update);
        const { type, object: payload, group_id: groupId } = update;
        const UpdateContext = webhookContexts[type] || UnsupportedEventContext;
        return this.dispatchMiddleware(new UpdateContext({
            api: this.api,
            upload: this.upload,
            payload,
            groupId,
            updateType: type,
            source: exports.UpdateSource.WEBHOOK
        }));
    }
    /**
     * Starts to poll server
     */
    startPolling() {
        const { pollingGroupId } = this.options;
        const isGroup = pollingGroupId !== undefined;
        this.pollingTransport.subscribe(isGroup
            ? this.handleWebhookUpdate.bind(this)
            : this.handlePollingUpdate.bind(this));
        return this.pollingTransport.start();
    }
    /**
     * Starts the webhook server
     */
    async startWebhook(options = {}) {
        return this.webhookTransport.start(options);
    }
    /**
     * Automatically determines the settings to run
     */
    async start({ webhook } = {}) {
        if (webhook) {
            await this.startWebhook(webhook);
            return;
        }
        if (!this.options.pollingGroupId) {
            try {
                const [group] = await this.api.groups.getById({});
                this.pollingTransport = new PollingTransport({
                    api: this.api,
                    ...this.options,
                    pollingGroupId: group.id
                });
                this.options.pollingGroupId = group.id;
            }
            catch (error) {
                if (error.code !== exports.APIErrorCode.PARAM) {
                    throw error;
                }
                debug('This is not a group.');
            }
        }
        await this.startPolling();
    }
    /**
     * Stopping gets updates
     */
    async stop() {
        await Promise.all([
            this.pollingTransport.stop(),
            this.webhookTransport.stop()
        ]);
    }
    /**
     * Returns webhook callback like http[s] or express
     */
    getWebhookCallback(path) {
        return this.webhookTransport.getWebhookCallback(path);
    }
    /**
     * Returns the middleware for the webhook under koa
     */
    getKoaWebhookMiddleware() {
        return this.webhookTransport.getKoaWebhookMiddleware();
    }
    /**
     * Calls up the middleware chain
     */
    dispatchMiddleware(context) {
        return this.composed(context, middlewareIo.noopNext);
    }
    /**
     * Reloads middleware
     */
    recompose() {
        this.composed = this.composer.compose();
    }
}
inspectable.inspectable(Updates, {
    // @ts-expect-error
    serialize: ({ isStarted, composer }) => ({
        isStarted,
        composer
    })
});

const { MISSING_CAPTCHA_HANDLER, MISSING_TWO_FACTOR_HANDLER } = exports.SharedErrorCode;
class CallbackService {
    /**
     * Checks if there is a captcha handler
     */
    get hasCaptchaHandler() {
        return this.captchaHandler !== undefined;
    }
    /**
     * Checks if there is a two-factor handler
     */
    get hasTwoFactorHandler() {
        return this.twoFactorHandler !== undefined;
    }
    /**
     * Sets a handler for captcha processing
     */
    onCaptcha(handler) {
        this.captchaHandler = handler;
        return this;
    }
    /**
     * Sets a handler for two factor processing
     */
    onTwoFactor(handler) {
        this.twoFactorHandler = handler;
        return this;
    }
    /**
     * Processing captcha
     */
    processingCaptcha(payload) {
        const { captchaHandler } = this;
        if (captchaHandler === undefined) {
            return Promise.reject(new VKError({
                message: 'Missing captcha handler',
                code: MISSING_CAPTCHA_HANDLER
            }));
        }
        return new Promise((resolveProcessing, rejectProcessing) => {
            captchaHandler(payload, (key) => (new Promise((resolve, reject) => {
                if (key instanceof Error) {
                    reject(key);
                    rejectProcessing(key);
                    return;
                }
                resolveProcessing({
                    key,
                    validate: {
                        resolve,
                        reject
                    }
                });
            })));
        });
    }
    /**
     * Processing two-factor
     */
    processingTwoFactor(payload) {
        const { twoFactorHandler } = this;
        if (twoFactorHandler === undefined) {
            return Promise.reject(new VKError({
                message: 'Missing two-factor handler',
                code: MISSING_TWO_FACTOR_HANDLER
            }));
        }
        return new Promise((resolveProcessing, rejectProcessing) => {
            twoFactorHandler(payload, (code) => (new Promise((resolve, reject) => {
                if (code instanceof Error) {
                    reject(code);
                    rejectProcessing(code);
                    return;
                }
                resolveProcessing({
                    code,
                    validate: {
                        resolve,
                        reject
                    }
                });
            })));
        });
    }
}

const onlyNumberRe = /^-?\d+$/;
const systemMentionRe = /\[([^|]+)\|[^\]]+\]/;
const isHttpsRe = /^https:\/\//i;
const isVKUrlRe = /^(?:https?:\/\/)?(?:m\.)?(?:vk\.(?:com|me|ru)|vkontakte\.ru)\//i;
const parseTargetResourceRe = /^(id|club|public|albums|tag|app)(-?\d+)$/i;
const parseOwnerResourceRe = /^(album|topic|page|photo|video|audio|doc|audio_message|graffiti|wall|market|poll|gift)(-?\d+)_(\d+)/i;
const enumResourceTypes = {
    id: exports.ResourceType.USER,
    club: exports.ResourceType.GROUP,
    public: exports.ResourceType.GROUP,
    app: exports.ResourceType.APPLICATION
};
const transformNumberResourceToTarget = (resource) => (resource < 0
    ? `club${-resource}`
    : `id${resource}`);
const transformMentionResourceToTarget = (resource) => {
    const { 1: mentionResource } = resource.match(systemMentionRe);
    return mentionResource;
};
const resolveTargetResouce = (resource) => {
    const { 1: rawType, 2: rawId } = resource.match(parseTargetResourceRe);
    return {
        id: Number(rawId),
        type: enumResourceTypes[rawType] || rawType
    };
};
const resolveOwnerResource = (resource) => {
    const { 1: rawType, 2: rawOwnerId, 3: rawId } = resource.match(parseOwnerResourceRe);
    return {
        id: Number(rawId),
        ownerId: Number(rawOwnerId),
        type: rawType
    };
};
const resolveSlugResource = async (resource, api) => {
    if (api === undefined) {
        throw new Error('API object is not passed');
    }
    const response = await api.utils.resolveScreenName({
        screen_name: resource
    });
    if (Array.isArray(response)) {
        throw new ResourceError({
            code: exports.ResourceErrorCode.RESOURCE_NOT_FOUND,
            message: 'Resource not found'
        });
    }
    return {
        id: response.object_id,
        type: response.type
    };
};
const resolveResource = async ({ resource: rawResource, api }) => {
    if (!rawResource) {
        throw new TypeError('Resource is required');
    }
    const resource = String(rawResource).trim();
    if (onlyNumberRe.test(resource)) {
        return resolveTargetResouce(transformNumberResourceToTarget(Number(resource)));
    }
    if (systemMentionRe.test(resource)) {
        return resolveTargetResouce(transformMentionResourceToTarget(resource));
    }
    if (parseOwnerResourceRe.test(resource)) {
        return resolveOwnerResource(resource);
    }
    if (parseTargetResourceRe.test(resource)) {
        return resolveTargetResouce(resource);
    }
    if (!isVKUrlRe.test(resource)) {
        return resolveSlugResource(resource, api);
    }
    const resourceUrl = !isHttpsRe.test(resource)
        ? `https://${resource}`
        : resource;
    const { pathname: rawPathname, searchParams } = new URL(resourceUrl);
    if (rawPathname === '/') {
        throw new ResourceError({
            code: exports.ResourceErrorCode.INVALID_URL,
            message: 'URL should contain path'
        });
    }
    const pathname = rawPathname.substring(1);
    const search = searchParams.get('w') || searchParams.get('z');
    if (search && parseOwnerResourceRe.test(search)) {
        return resolveOwnerResource(search);
    }
    if (parseOwnerResourceRe.test(pathname)) {
        return resolveOwnerResource(pathname);
    }
    if (parseTargetResourceRe.test(pathname)) {
        return resolveTargetResouce(pathname);
    }
    return resolveSlugResource(pathname, api);
};

/**
 * Main class
 */
class VK {
    /**
     * Constructor
     */
    constructor(options) {
        this.callbackService = options.callbackService
            || new CallbackService();
        this.api = new API({
            ...options,
            callbackService: this.callbackService
        });
        this.upload = new Upload({
            ...options,
            api: this.api
        });
        this.updates = new Updates({
            ...options,
            api: this.api,
            upload: this.upload
        });
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
}
inspectable.inspectable(VK, {
    serialize: ({ api, updates }) => ({ api, updates })
});

Object.defineProperty(exports, 'Composer', {
	enumerable: true,
	get: function () { return middlewareIo.Composer; }
});
exports.API = API;
exports.APIError = APIError;
exports.APIRequest = APIRequest;
exports.APIWorker = APIWorker;
exports.Attachment = Attachment;
exports.Attachmentable = Attachmentable;
exports.AudioAttachment = AudioAttachment;
exports.AudioMessageAttachment = AudioMessageAttachment;
exports.CallbackService = CallbackService;
exports.Chain = Chain;
exports.CollectError = CollectError;
exports.CommentContext = CommentContext;
exports.Context = Context;
exports.DialogFlagsContext = DialogFlagsContext;
exports.DialogMessagesContext = DialogMessagesContext;
exports.DialogNotificationSettingsContext = DialogNotificationSettingsContext;
exports.DocumentAttachment = DocumentAttachment;
exports.DonutSubscriptionContext = DonutSubscriptionContext;
exports.DonutSubscriptionPriceContext = DonutSubscriptionPriceContext;
exports.DonutWithdrawContext = DonutWithdrawContext;
exports.ExecuteError = ExecuteError;
exports.ExternalAttachment = ExternalAttachment;
exports.FriendActivityContext = FriendActivityContext;
exports.GiftAttachment = GiftAttachment;
exports.GraffitiAttachment = GraffitiAttachment;
exports.GroupMemberContext = GroupMemberContext;
exports.GroupUpdateContext = GroupUpdateContext;
exports.GroupUserContext = GroupUserContext;
exports.Keyboard = Keyboard;
exports.KeyboardBuilder = KeyboardBuilder;
exports.LikeContext = LikeContext;
exports.LinkAttachment = LinkAttachment;
exports.MarketAlbumAttachment = MarketAlbumAttachment;
exports.MarketAttachment = MarketAttachment;
exports.MarketOrderContext = MarketOrderContext;
exports.MessageContext = MessageContext;
exports.MessageEventContext = MessageEventContext;
exports.MessageFlagsContext = MessageFlagsContext;
exports.MessageForwardsCollection = MessageForwardsCollection;
exports.MessageSubscriptionContext = MessageSubscriptionContext;
exports.MessagesReadContext = MessagesReadContext;
exports.NewAttachmentsContext = NewAttachmentsContext;
exports.Objects = objects;
exports.ParallelSelectedWorker = ParallelSelectedWorker;
exports.ParallelWorker = ParallelWorker;
exports.Params = params;
exports.PhotoAttachment = PhotoAttachment;
exports.PollAttachment = PollAttachment;
exports.PollingTransport = PollingTransport;
exports.ResourceError = ResourceError;
exports.Responses = responses;
exports.SequentialWorker = SequentialWorker;
exports.StickerAttachment = StickerAttachment;
exports.StoryAttachment = StoryAttachment;
exports.TypingContext = TypingContext;
exports.UnsupportedEventContext = UnsupportedEventContext;
exports.Updates = Updates;
exports.UpdatesError = UpdatesError;
exports.Upload = Upload;
exports.UploadError = UploadError;
exports.VK = VK;
exports.VKAppPayloadContext = VKAppPayloadContext;
exports.VKError = VKError;
exports.VKPayTransactionContext = VKPayTransactionContext;
exports.VideoAttachment = VideoAttachment;
exports.VoteContext = VoteContext;
exports.WallAttachment = WallAttachment;
exports.WallPostContext = WallPostContext;
exports.WallReplyAttachment = WallReplyAttachment;
exports.WebhookTransport = WebhookTransport;
exports.applyMixins = applyMixins;
exports.createCollectIterator = createCollectIterator;
exports.executes = executes;
exports.getRandomId = getRandomId;
exports.kSerializeData = kSerializeData;
exports.parseAttachmentRe = parseAttachmentRe;
exports.resolveResource = resolveResource;
exports.transformAttachments = transformAttachments;
